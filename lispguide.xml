<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="styleguide.xsl"?>
<GUIDE title="Google Common Lisp スタイルガイド 日本語訳">

<div align="center">
これは<a href="http://google-styleguide.googlecode.com/svn/trunk/lispguide.xml">Google Common Lisp Style Guide (1.20)</a>の日本語訳です。<br/>
オリジナルと同様、<a href="http://creativecommons.org/licenses/by/3.0/">CC-By 3.0 License</a>で配布します。<br/>
最終更新: 2013-09-11
</div>

<p align="right">
Revision 1.20
</p>


<address>
Robert Brown
</address>
<address>
  <a HREF="mailto:tunes@google.com">François-René Rideau</a>
</address>

<address>
  Dan Weinrebに捧ぐ
</address>

<p align="right">
日本語訳:現在進行中(求共訳者)
</p>
<!-- 皆さんお名前はご自由に直してください -g000001 
     順番は大体の量に比例
-->
<address>
TOYOZUMIKouichi
</address>
<address>
@g000001
</address>
<address>
@guicho271828
</address>
<address>
佐野匡俊
</address>
<address>
Takashi Kato
</address>
<address>
@ponkore
</address>
<address>
(訳文アドバイスを頂いた皆さん: @nfunato, @omasanori, etc)
</address>
<p align="center">
<cite>「パターンとは『適切な語彙がなかった』ことの言い換えだ」</cite> — Rich Hickey
<!-- https://twitter.com/omasanori/status/274389170603044864  -->
<!-- Patterns mean "I have run out of language."  -->
</p>

<OVERVIEW>
<CATEGORY title="重要事項">
  <STYLEPOINT title="詳細情報の表示">
     <SUMMARY>
      <!-- This style guide contains many details that are initially
           hidden from view. They are marked by the triangle icon,
           which you see here on your left. Click it now. You should
           see "Hooray" appear below. -->
       このスタイルガイドには詳細情報がたくさん盛り込まれていますが、最
       初は表示されていません。左端にある矢印ボタンをクリックしてみてく
       ださい。 「ヒャッホー!」と表示されるはずです。
     </SUMMARY>
     <BODY>
       <p>
        <!-- Hooray!  Now you know you can expand points to get more
             details. Alternatively, there's an "expand all" at the
             top of this document.-->
        ヒャッホー! このように矢印ボタンをクリックすると詳細情報が表示されます。
	このドキュメントの先頭にある大きな矢印ボタンをクリックしても構いません。
	そうすれば、すべての詳細情報が表示されます。訳注は[]で囲んで表わします。
	<!-- とりあえず []で表記することにしてみました。-->
       </p>
     </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="背景">
  <p>
    <!--
    Common Lisp is a powerful multiparadigm programming language.
    With great power comes great responsibility.
    -->
    Common Lispは強力なマルチパラダイム言語です。
    強力さには責任が伴います。
  </p>
  <p>
    <!--
    This guide recommends formatting and stylistic choices
    designed to make your code easier for other people to understand.
    -->
    このガイドはあなたのコードを他人にとって理解しやすくするよう設計された書式とスタイルの選択を奨励します。

    <!--
    For those internal applications and free software libraries that
    we develop at Google,
    you should keep within these guidelines when making changes.
    Note however that each project has its own rules and customs
    that complement or override these general guidelines;
    the speed-oriented QPX low fare search engine notably
    has a very different style and feel from the QRes reservation system.
    -->
    Googleで開発される内製アプリケーション及びフリーソフトに対して変更を行う際は、
    このガイドラインに沿ったものにする必要があります。
    しかし、それぞれのプロジェクトには独自のルールや習慣があり、
    それらはこれらの一般的なガイドラインを補足もしくは上書きします;
    とりわけ速度重視の低コスト検索エンジンQPXは
    QRes予約システムとはとても異なるルック＆フィールで作られています。
  </p>
  <p>
    <!--
    If you're writing Common Lisp code outside Google,
    we invite you to consider these guidelines.
    -->
    もしあなたがGoogle以外でCommon Lispのコードを書くのであれば、
    これらガイドラインの項目について検討されることをお勧めします。
    <!-- You may find some of them useful -->
    <!-- where they don't conflict with other priorities you have. -->
    <!-- We welcome remarks and constructive feedback -->
    <!-- on how to improve our guide, and -->
    <!-- on what alternate styles work for you and why. -->
    他のあなたが規範としている既定の[ガイドライン]と競合しない限りにおいて、
    これらの中に有用とされるものがあるかもしれません。
    我々のガイドを改善することについてのご意見、そして別のスタイルの提案と、
    その別のスタイルが、どうしてあなたの元では上手く機能するのか、の建設的なフィードバックを歓迎しています。
  </p>
  <p>
    <!--
    This guide is not a Common Lisp tutorial.
    For basic information about the language, please consult
    <a HREF="http://www.gigamonkeys.com/book/">Practical Common Lisp</a>.
    For a language reference, please consult the
    <a HREF="http://www.lispworks.com/documentation/HyperSpec/Front/index.htm">Common Lisp HyperSpec</a>.
    For more detailed style guidance, take a look at Peter Norvig and Kent Pitman's
    <a HREF="http://norvig.com/luv-slides.ps">style guide</a>.
    -->
    このガイドはCommon Lispのチュートリアルではありません。
    言語についての基礎的な情報については
    <a HREF="http://www.gigamonkeys.com/book/">Practical Common Lisp</a>を参照して下さい。
    言語リファレンスとしては
    <a HREF="http://www.lispworks.com/documentation/HyperSpec/Front/index.htm">Common Lisp HyperSpec</a>
    を参照して下さい。より詳細なスタイルガイドについてはPeter Norvig とKent Pitmanの
    <a HREF="http://norvig.com/luv-slides.ps">style guide</a>を見て下さい。
  </p>
</CATEGORY>
</OVERVIEW>
<CATEGORY title="メタガイド"><!-- Meta-Guide -->
  <STYLEPOINT title="Must,Should,May,Not">
    <!-- (佐野:同上な理由で「要求レベルの表記方法」？) --><!-- Must, Should, May, or Not -->
    <SUMMARY>
      <!--
      Each guideline's level of importance is indicated
      by use of the following keywords and phrases, adapted from
      <a href="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.
      -->
      それぞれのガイドラインの重要度のレベルは
      <a href="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>から
      採用した以下の語句で示します。
    </SUMMARY>
    <BODY>
      <table>
        <tr>
          <th valign="top">MUST</th>
          <td>
            <p>
              <!--
              This word, or the terms "REQUIRED" or "SHALL",
              means that the guideline is an absolute requirement.
              You must ask permission to violate a MUST.
              -->
              (佐野:実際の訳語をどうするか)"MUST"、"REQUIRED"、"SHALL"といった用語は
              そのガイドラインが絶対的な要求であることを意味します。
              MUSTに違反する場合許可を求める必要(佐野:用語統一[must])があります。
            </p>
          </td>
        </tr>
        <tr>
          <th valign="top">MUST NOT</th>
          <td>
            <p>
              <!--
              This phrase, or the phrase "SHALL NOT",
              means that the guideline is an absolute prohibition.
              You must ask permission to violate a MUST NOT.
              -->
              "MUST NOT"や"SHALL NOT"といった句は
              そのガイドラインが絶対的な禁止であることを意味します。
              MUST NOTに違反する場合許可を求める必要(佐野:用語統一[must])があります。
            </p>
          </td>
        </tr>
        <tr>
          <th valign="top">SHOULD</th>
          <td>
            <p>
              <!--
              This word, or the adjective "RECOMMENDED", means that
              there may exist valid reasons in particular circumstances
              to ignore the demands of the guideline, but
              the full implications must be understood and carefully weighed
              before choosing a different course.
              You must ask forgiveness for violating a SHOULD.
              -->
              語"SHOULD"や形容詞"RECOMMENDED"は
              ある状況ではガイドの要求を無視する適切な理由があるかもしれないことを意味しますが、
              他のやりかたを選択する前にガイドの含意は理解され注意し重視される必要(佐野:用語統一[must])があります。
              SHOULDに違反する場合許容を求める必要(佐野:用語統一[must])があります。
            </p>
          </td>
        </tr>
        <tr>
          <th valign="top">SHOULD NOT</th>
          <td>
            <p>
              <!--
              This phrase, or the phrase "NOT RECOMMENDED", means that
              there may exist valid reasons in particular circumstances
              to ignore the prohibitions of this guideline, but
              the full implications should be understood and carefully weighed
              before choosing a different course.
              You must ask forgiveness for violating a SHOULD NOT.
              -->
              句"SHOULD NOT"と句"NOT RECOMMENDED"は
              ある状況ではガイドの禁止を無視する適切な理由があるかもしれないことを意味しますが、
              他のやりかたを選択する前にガイドの含意は理解され注意し重視される必要(佐野:用語統一[must])があります。
              SHOULD NOTに違反する場合許容を求める必要(佐野:用語統一[must])があります。
            </p>
          </td>
        </tr>
        <tr>
          <th valign="top">MAY</th>
          <td>
            <p>
              <!--
              This word, or the adjective "OPTIONAL",
              means that an item is truly optional.
              -->
              語"MAY"や形容詞"OPTIONAL"はその項目は本当に任意であることを意味する。
            </p>
          </td>
        </tr>
      </table>
      <p>
        <!--
        Unlike RFCs, we don't capitalize every instance of one of the above
        keywords when it is used.
        -->
        RFCとは異なり、上記キーワードの利用全てを大文字で表記するわけではありません。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="許可と許容"><!-- Permission and Forgiveness -->
    <SUMMARY>
      <!--
      There are cases where transgression of some of these rules
      is useful or even necessary.
      In some cases, you must seek permission or obtain forgiveness
      from the proper people.
      -->
      ガイドで示すルールに対する違反が有効であったり必要であるケースがあります。
      いくつかのケースでは許可を探すことや適切な人からの許容を求める必要(佐野:[must]訳語統一)があります
    </SUMMARY>
    <BODY>
      <p>
        <!--Permission comes from the owners of your project.-->
        許可はあなたのプロジェクトの所有者に由来する。
      </p>
      <p>
        <!--
        Forgiveness is requested in a comment near the point of guideline violation, 
        and is granted by your code reviewer.
        The original comment should be signed by you, and
        the reviewer should add a signed approval to the comment at review time.
        -->
        許容はガイドライン違反をした場所の近くのコメントの中でリクエストされ、レビューアによって承諾されます。
        オリジナルのコメントはあなた(佐野:起票行為者の意味で行くと日本語での「あなた」はどうだろう)の名前で署名されるべき(佐野:[should]訳語統一)で、レビューアは
        レビュー時に署名した承認を追記すべき(佐野:[should]訳語統一)です。
      </p>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="慣例"><!-- Conventions -->
    <SUMMARY>
      <!-- You MUST follow conventions. They are not optional. -->
      あなたは、慣例を確認しなければなりません。これは自由選択ではありません。
    </SUMMARY>
    <BODY>
      <p>
        <!-- Some of these guidelines are motivated by universal principles of good programming. -->
        これらのガイドラインのいくつかは、よいプログラミングの普遍的な方針として設けられています。
        <!-- Some guidelines are motivated by technical peculiarities of Common Lisp. -->
	いくつかのガイドラインは、Common Lispの技術的に特別な面に基づいています。
        <!-- Some guidelines where once motivated by a technical reason, -->
        <!-- but the guideline remained after the reason subsided. -->
	いくつかのガイドラインは単に技術的な理由に基づいていますが、ガイドラインはその理由がなくなったときに、見直されます。
        <!-- Some guidelines, such those about as comments and indentation, -->
        <!-- are based purely on convention, rather than on clear technical merit. -->
	いくつかのガイドラインはコメントや字下げに関するもので、明確な技術的利点よりも純粋な議論に基づいています。
        <!-- Whatever the case may be, you must still follow these guidelines, -->
        <!-- as well as other conventional guidelines -->
        <!-- that have not been formalized in this document. -->
	いかなる場合でもあなたはこれらのガイドラインだけでなく、他の
	この文書の中に形式化されていないガイドラインにも従わなければなりません。
      </p>
      <p>
	<!--
        You MUST follow conventions.
        They are important for readability.
        When conventions are followed by default,
        violations of the convention are a signal
        that something notable is happening and deserves attention.
        When conventions are systematically violated,
        violations of the convention are a distracting noise
        that needs to be ignored.
	-->
	慣例には従わなければなりません。慣例は可読性を向上させます。<!-- 直訳だと日本語がおかしくなるので意訳。-->
	慣例が既定にしたがっていれば、慣例違反は注目に値する何かが起きていて、注意を払う必要があるシグナルになります。
	意図的に違反された慣例は、無視されなければならない邪魔なノイズになります。<!-- 訳微妙 -->
      </p>
      <p>
	<!--
        Conventional guidelines <em>are</em> indoctrination.
        Their purpose is to make you follow the mores of the community,
        -->
	慣例に沿ったガイドラインはある種の宗教に<em>なります</em>。<!-- 教化と訳すよりは・・・ -->
	これらの目的はあなたをコミュニティの教義に則らせ、より効果的に既存のメンバーと協力することを可能にすることです。
	<!-- ちょっと日本語がおかしい。-->
	<!--
        so you can more effectively cooperate with existing members.
	-->
        It is still useful to distinguish the parts that are technically motivated
        from the parts that are mere conventions,
        so you know when best to defy conventions for good effect,
        and when not to fall into the pitfalls that the conventions are there to help avoid.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="古いコード"><!-- Old Code -->
    <p>
      <!-- A lot of our code was written before these guidelines existed. -->
      我々のコードのうちの多くは、これらガイドラインができる以前に書かれました。
      <!-- You should fix violations as you encounter them -->
      <!-- in the course of your normal coding. -->
      あなたは普段のコーディングの間に遭遇したガイドラインに対する違反を修正していくべきです。
      <!-- You must not fix violations en masse -->
      <!-- without warning other developers and coordinating with them, -->
      <!-- so as not to make the merging of large branches -->
      <!-- more difficult than it already is. -->
      あなたは、巨大なブランチの統合でいまよりも状況をややこしくすることを避けるために、
      違反のすべて一時に、他の開発者に対する警告と話し合いなしに修正してはなりません。
    </p>
  </STYLEPOINT>
  <STYLEPOINT title="将来の課題"><!-- Future Topics -->
    <SUMMARY>
      <!-- There are many topics for additional standardization -->
      <!-- not covered by current version of this document, -->
      <!-- but deferred to future versions. -->
      ここには多くの追加の標準化すべき事柄があり、現在のバージョンのこの文書にはありませんが、将来のバージョンに延期されています。
    </SUMMARY>
    <BODY>
      <ul>
        <li>
          <!-- File and directory structure -->
	  ファイルとディレクトリ構造
        </li>
        <li>
          <!-- Packages and modularity -->
	  パッケージとモジュール性
        </li>
        <li>
          <!-- Threads and locking -->
	  スレッドとロック
        </li>
        <li>
          <!-- How to add configurable components -->
	  設定可能な部品の追加方法
        </li>
        <li>
          <!-- CLOS style: initforms, slot and accessor names, etc. -->
	  CLOSスタイル:初期化方法、スロットおよびアクセサの名前など
        </li>
        <li>
          <!-- Recommendations on max number of slots per class. -->
	  クラスあたりのスロット数の推奨される最大の数
        </li>
        <li>
          <!-- More concrete examples of good code: -->
	  より具体的なよいコードの例
          <ul>
            <li>
              <!-- exceptions -->
	      例外
            </li>
            <li>
              <!-- transactions, with retry -->
	      トランザクションとリトライ
            </li>
            <li>
              XML
            </li>
            <li>
              <!-- typing -->
	      型
            </li>
            <li>
              <!-- encapsulation / abstraction -->
	      カプセル化と抽象化
            </li>
            <li>
              <!-- class and slot names -->
	      クラスとスロットの名前
            </li>
            <li>
              <!-- etc. -->
	      など
            </li>
          </ul>
        </li>
        <li>
          <!-- When (not) to use conditional compilation: -->
	  条件付コンパイルの(非)使用時：<!-- compilation = コンパイル？ or 編集?-->
          <ul>
            <li>
              <!-- modifying the product -->
	      プロダクトの修正
            </li>
            <li>
              <!-- conditional debugging/console output/etc. -->
	      条件付デバッグ、コンソール出力、など
            </li>
            <li>
              <!-- "temporarily" commenting-out blocks of code -->
	      "一時的な"コードのコメント化
            </li>
            <li>
              <!-- etc. -->
	      など
            </li>
          </ul>
        </li>
      </ul>
    </BODY>
  </STYLEPOINT>
  </CATEGORY>
<CATEGORY title="基本的なガイドライン"><!-- General Guidelines -->
  <STYLEPOINT title="方針"><!-- Principles -->
    <SUMMARY>
      <!-- There are some basic principles for team software development -->
      <!-- that every developer must keep in mind. -->
      ここにはチームでソフトウェア開発をするにあたってすべての開発者が心にとめておくべきいくつかの基本的な方針を記してあります。
      <!-- Whenever the detailed guidelines are inadequate, confusing or contradictory, -->
      <!-- refer back to these principles for guidance: -->
      ガイドラインの詳細が、不適切な、混乱を引き起こす、または矛盾している場合は方針について再度参照してください。
      <ul>
        <li>
	  <!--
          Every developer's code must be easy for another developer
          to read, understand, and modify
 	  — even if the first developer isn't around to explain it.
          (This is the "hit by a truck" principle.)
	  -->
	  全ての開発者が書いたコードは他の開発者にとって簡単に読めて、理解でき、修正できなければなりません。
	  例え最初の開発者が近くに居らず説明不可能であっても。([もし主要開発者が]トラックにはねられたらの原理)
          <!-- なんのこと？ -->
          <!-- http://en.wikipedia.org/wiki/Bus_factor 主要開発者がトラックにはねられて死んだもプロジェクトは続行できなくてはならない的な比喩みたいです: g000001 -->
        </li>
        <li>
	  <!-- 
          Everybody's code should look the same.
          Ideally, there should be no way to look at lines of code
          and recognize it as "Fred's code" by its style.
	  -->
	  全ての人のコードは同じに見えるべきです。
	  理想としては、コードを見て「Fredが書いたな」と判別できるべきではありません。<!-- 単語を全部入れるべき？ -->
        </li>
        <li>
          <!-- Be precise. -->
	  精密に。
        </li>
        <li>
          <!-- Be concise. -->
	  簡潔に。
        </li>
        <li>
          <!-- KISS — Keep It Simple, Stupid. -->
	  KISSの原則を守りましょう。単純にしておきましょう、愚かに(Keep It Simple Stupid)。
        </li>
        <li>
          <!-- Use the smallest hammer for the job. -->
	  牛刀を使って鶏を割くことのないように。
	  <!-- って書くのが日本語として熟れていると思うのですが、そうすると下の方の「small hammer」をどう処理するかが問題です。TOYOZUMI -->
        </li>
        <li>
          <!-- Use common sense. -->
	  一般的な価値基準を用います。
        </li>
        <li>
          <!-- Keep related code together. -->
          <!-- Minimize the amount of jumping around -->
          <!-- someone has to do to understand an area of code. -->
	  関連するコードは近くに。
	  コードのあいだのジャンプは誰もが把握できる範囲で最小限に抑えます。
        </li>
      </ul>
    </SUMMARY>
    <BODY>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="優先順位"><!-- Priorities -->
    <SUMMARY>
      <p>
        <!-- When making decisions about how to write a given piece of -->
        <!-- code, aim for the following -ilities in this priority order: -->
	コードをどう書くかということを決定する際に、どんな「~やすさ」に重きをおくかはこの優先順位に従います。
      </p>
      <ul>
        <li>
          <!-- Usability by the customer -->
	  顧客にとっての使いやすさ
        </li>
        <li>
          <!-- Debuggability/Testability -->
	  デバッグのしやすさ、テストのしやすさ
        </li>
        <li>
          <!-- Readability/Comprehensibility -->
	  読みやすさ、理解しやすさ
        </li>
        <li>
          <!-- Extensibility/Modifiability -->
	  デバッグのしやすさ、テストのしやすさ
        </li>
        <li>
          <!-- Efficiency (of the Lisp code at runtime) -->
	  (Lispコードの実行時の)性能の引き出しやすさ
        </li>
      </ul>
    </SUMMARY>
    <BODY>
      <p>
        <!-- Most of these are obvious. -->
	これらのうちほとんどは明白です。
      </p>
      <p>
        <!-- Usability by the customer means that the system has to do what the -->
        <!-- customer requires; it has to handle the customer's transaction -->
        <!-- volumes, uptime requirements; etc. -->
	顧客にとっての使いやすさとは、顧客がどうしてほしいかをシステムが持っていることを意味します。
	これは顧客のトランザクションの大きさや稼働時間要求などによって左右されます。
      </p>
      <p>
        <!-- For the Lisp efficiency point, -->
        <!-- given two options of equivalent complexity, -->
        <!-- pick the one that performs better. -->
        <!-- (This is often the same as the one that conses less, -->
        <!-- i.e. allocates less storage from the heap.) -->
	Lispを効率的なものにするために、二つの同程度を複雑な選択肢から、
	性能の良いものを選びます。
	(これはしばしば、コンシングの少ない方、という意味と等価です。
	つまり、ヒープから割り当てる領域が少なくて済む方、ということです）
      </p>
      <p>
        <!-- Given two options where one is more complex than the other, -->
        <!-- pick the simpler option and revisit the decision only if -->
        <!-- profiling shows it to be a performance bottleneck. -->
	与えられた二つの選択肢のうち、より複雑な方は、
	簡単な選択肢を選んで、性能のボトルネックとなる点をプロファイリングによって
	決定できたとき、もう一度やりなおすことです。
      </p>
      <p>
        <!-- However, avoid premature optimization. -->
        <!-- Don't add complexity to speed up something that runs rarely, -->
        <!-- since in the long run, it matters less whether such code is fast. -->
	しかし、時期尚早な最適化は避けます。
	滅多に走らない部分の高速化のために複雑ななにかを追加すべきではありません。
	長い目で見るとそれはコードの高速化のためにさほど役に立ちません。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="設計"><!-- Architecture -->
    <SUMMARY>
      To build code that is robust and maintainable,
      it matters a lot how the code is divided into components,
      how these components communicate,
      how changes propagate as they evolve,
      and more importantly
      how the programmers who develop these components communicate
      as these components evolve.
    </SUMMARY>
    <BODY>
      <p>
        <!-- If your work affects other groups, might be reusable across groups, -->
        <!-- adds new components, has an impact on other groups -->
        <!-- (including QA or Ops), or otherwise isn't purely local, -->
        <!-- you must write it up using at least a couple of paragraphs, -->
        <!-- and get a design approval from the other parties involved -->
        <!-- before starting to write code — or be ready to scratch what you have -->
        <!-- when they object. -->
	もしあなたの仕事がほかのグループに影響を及ぼし、もしかするとグループの垣根を越えて再利用可能かもしれず、
	あたらしい部品を追加され、（QAあるいはOpsを含めて）ほかのグループにおいて衝撃を与えるとき、
	あるいは純粋に局地的なものでないとき、
	あなたはそれらを最低でも数行の文章に書き起こし、
	設計に対する指示をコードを書き始める前にをるいは、彼らのオブジェクトを自ら一から作る前に、
	関連するほかの集団からも取り付けなければいけません。
      </p>
      <p>
        If you don't know or don't care about these issues,
        ask someone who does.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="ライブラリの使用"><!-- Using Libraries -->
    <SUMMARY>
      <!-- Often, the smallest hammer is to use an existing library. -->
      <!-- Or one that doesn't exist yet. -->
      <!-- In such cases, you are encouraged to use or develop such a library, -->
      <!-- but you must take appropriate precautions. -->
      しばしば、鶏を捌くのに最適な包丁<!-- 上記の牛刀に合わせました -->は既存のライプラリの中にあります。
      あるいは、どこにもありません。
      それぞれの場合において、あなたはそれぞれライブラリを使うか開発することを
      奨められますが、あなたは適切な備えを講じなければなりません。
    </SUMMARY>
    <BODY>
      <ul>
        <li>
          <!-- You MUST NOT start a new library -->
          <!-- unless you established that none is already available -->
          <!-- that can be fixed or completed into becoming what you need. -->
	  自分が必要とするものが修正や補完で手に入るにもかかわらず、
	  既存のライブラリにそれがない場合を除いて、あなたは新しいライブラリの開発を開始してはなりません。
          <!-- That's a rule against the NIH syndrome ("Not Invented Here"), -->
          <!-- which is particularly strong amongst Lisp hackers. -->
	  このルールはLispハッカーには重症患者の多い、
	  NIH("Not Invented Here"ここでつくられていない）症候群に対抗するものです。
        </li>
        <li>
          <!-- Whichever library, old or new, you pick, you MUST get permission -->
          <!-- to incorporate third-party code into the code base. -->
	  古いものであれ、新しいものであれ、どちらにせよライブラリをあなたが選んだら、
	  あなたはコードベースへ第三者の作ったコードを組み込むために、
	  許可を得なくてはなりません。
          <!-- You must discuss the use of such library -->
          <!-- in the appropriate mailing-list, -->
          <!-- and have your code reviewed by people knowledgeable in the domain -->
          <!-- and/or the Lisp library ecosystem (if any). -->
	  あなたはそれぞれのライブラリを使用することについて、
	  適切なメーリングリストで議論しなければならず、
	  またあなたのコードをドメインと(もしあれば)Lispライブラリのエコシステムに
	  詳しい人に査読してもらわなければなりません。
          <!-- Please be ready to argue why this particular solution makes sense -->
          <!-- as compared to other available libraries. -->
        </li>
        <li>
          <!-- Some libraries are distributed under licenses not compatible -->
          <!-- with the software you're writing, and -->
          <!-- must not be considered available for use. -->
	  いくつかのライブラリはあなたが書いているソフトウェアと互換性のないライセンスで
	  配布されていて、使用できるものと考えてはなりません。
          <!-- Be aware of these issues, or consult with people who are. -->
	  これらの問題を認識し、あるいは認識している人に相談してください。
        </li>
      </ul>

    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="Open-Sourcing Code">
    <SUMMARY>
      <p>
        <!-- If you write a general-purpose library, -->
        <!-- or modify an existing open-source library, -->
        <!-- you are encouraged to publish the result -->
        <!-- separate from your main project and then -->
        <!-- have your project import it like any other open-source library. -->
	あなたが総合的な用途のライブラリを書いていたり、
	既存のオープンソースコードを修正しているときは、
	あなたはその成果をあなたの本来のプロジェクトから切り離して、
	配布し、他のオープンソースライブラリと同様にあなたのプロジェクトに組み入れる
	ことを推奨されます。
      </p>
      
    </SUMMARY>
    <BODY>
      <p>
        <!-- Use your judgment to distinguish -->
        <!-- general-purpose versus business-specific code, -->
        <!-- and open-source the general-purpose parts, -->
        <!-- while keeping the business-specific parts a trade secret. -->
	総合的な用途のための部品をオープンソース化し、
	業務に固有の部品を企業秘密に保ち続けるために、
	総合的な用途に使われるコードか、業務に固有のコードかを識別するあなたの判断が利用されます。
      </p>
      
      <p>
        <!-- Open-Sourcing code has many advantages, -->
        <!-- including being able to leverage third parties for development, -->
        <!-- letting the development of features be user-directed, -->
        <!-- and keeping you honest with respect to code quality. -->
	オープンソース化されたコードは開発に第三者の梃子を入れ、
	ユーザが直接機能を開発することを許し、あなたがコードの品質に対して経緯を持ち続けるようにすることをはじめとして、
	多くの長所を持ちます。
        <!-- Whatever code you write, you will have to maintain anyway, -->
        <!-- and make sure its quality is high enough to sustain use in production. -->
	あなたはどんなコードを書く時でも、とにかくそれを維持し、
	製品の中で使い続けるために、必要十分なだけの高い品質を作り出さなければなりません。
        <!-- There should therefore be no additional burden to Open-Sourcing, -->
        <!-- even of code that (at least initially) -->
        <!-- is not directly usable by third parties. -->
	第三者にとって直接的に使いやすさにつながらない(最小限の)コードでも同じことですから、
	オープンソース化によって新たに負荷があなたにかかることはないでしょう。
      </p>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="開発手順"><!-- Development Process -->
    <SUMMARY>
      <!-- Development process is outside the scope of this document. -->
      開発手順は、このドキュメントの対象範囲外です。
      <!-- However, developers should remember at least these bits: -->
      <!-- get reviewed, write tests, eliminate warnings, run tests, avoid mass-changes. -->
      しかし、開発者は少なくとも次に示すことに気をとどめておくべきです:
      査読を受けること、テストを書くこと、警告をなくすこと、テストを走らせること、大規模な変更を避けること。
    </SUMMARY>
    <BODY>
      <p>
      </p>
      <ul>
        <li>
          <!--   All code changes must be reviewed. -->
	  すべてのコードの変更は査読されなければなりません。
          <!--   You should expect that your code will be reviewed by other hackers, -->
          <!--   and that you will be assigned other hackers' code to review. -->
	  あなたは自分のコードが他のハッカーに査読されることを期待すべきですし、
	  またあなたは他のハッカーのコードの査読に参加すべきです。
          <!--   Part of the review criteria will be that code obeys -->
          <!--   the coding standards in this document. -->
	  査読の際の基準は、この文書にあるコーディング基準をそのコードが守っているか、ということです。
        </li>
        <li>
          <!--   You must write and check-in tests for new code that you write and old bugs you fix. -->
	  あなたは、古いバグを修正するためのあなたの書いた新しいコードのために、
	  テストを書いてチェックインしなければなりません。
          <!--   There must be a unit test for every API function, -->
          <!--   and any previously failing case. -->
	  それらは、すべてのAPI関数についてのものであり、
	  また既知の失敗する条件のためのユニットテストでなければなりません。
          <!--   Your work is not truly done until this activity is complete. -->
	  あなたの仕事はこの活動が終了するまで真に終了したとはいえません。
          <!--   Estimating tasks must include the time it takes to produce such tests. -->
	  工数の見積もりは、その工程についてのテストが要する時間を含んでいなければなりません。
        </li>
        <li>
          <!--   Your code must compile -->
          <!--   without any compilation error or warning messages whatsoever. -->
	  あなたのコードは、あらゆるコンパイルエラーや警告メッセージを発生させずにコンパイルされなければなりません。
          <!--   If the compiler issues warnings that should be ignored, -->
          <!--   muffle those warnings using the -->
          <!--   <code>xcvb-driver:with-controlled-compiler-conditions</code> and -->
          <!--   <code>xcvb-driver:*uninteresting-conditions*</code> -->
          <!--   framework (also available as <code>asdf-condition-control</code>), -->
          <!--   either around the entire project, or around individual files -->
          <!--   (using asdf's <code>:around-compile</code> hooks). -->
	  もし、コンパイラの問題で警告を無視させるときはそれぞれの警告を
          <code>xcvb-driver:with-controlled-compiler-conditions</code>と
          <code>xcvb-driver:*uninteresting-conditions*</code>フレームワーク 
	  (ときには<code>asdf-condition-control</code>という名前で使用可能です)を使って
	  プロジェクト全体にわたってあるいは独立したファイルを包みます
          (asdfの<code>:around-compile</code>フックを使います)。
        </li>
        <li>
          <!--   All code should be checked in an appropriate source control system, -->
          <!--   in a way that allows for complete reproducibility of -->
          <!--   build, test and execution of -->
          <!--   the code that is, has been or may be deployed. -->
	  すべてのコードは、完全にビルドを再構築できて、そのコードをテストし、実行し、
	  配布されたあるいは配布されるかもしれない状態で、
	  適切なソースコード管理システムにチェックインすべきです。
        </li>
        <li>
          <!--   You must run the "precheckin" tests, and each component must pass -->
          <!--   its unit tests successfully before you commit any code. -->
	  あなたはいかなるコードをチェックインするときでも、その前に、
	  「チェックイン前」テストを走らせ、それぞれの部品がそのユニットテストを通過することを
	  確認しなければなりません。
        </li>
        <li>
          <!--   You should incorporate code coverage into your testing process. -->
          <!--   Tests are not sufficient -->
          <!--   if they do not cover all new and updated code; -->
	  あなたはあなたのテスト工程の範囲にコードを取り入れるようにすべきです。
	  テストがすべての新しい、あるいは更新されたコードを対象にできていないのなら、
	  そのテストは十分ではありません。
          code that for whatever reason cannot be included in coverage results
          should be clearly marked as such including the reason.
        </li>
        <li>
          <!--   Many people develop on branches. -->
	  多くの人々はブランチ上で開発します。
          <!--   You must get permission to undertake mass-changes -->
          <!--   (e.g. mass reindentations) -->
          <!--   so that we can coordinate in advance, -->
          <!--   and give branch residents time to get back on the mainline -->
	  あなたは巨大な変更（例えば全体にわたる字下げのやり直し）に対して、
	  それによって起きる影響を事前に調整して、
	  ブランチ上での開発者にメインラインとの差分を小さくするための、
	  十分な時間を与えるために、
	  その変更についての権限を得なければなりません。
        </li>
      </ul>
    </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="Formatting">
  <!-- <STYLEPOINT title="Spelling"> -->
    <STYLEPOINT title="綴り">
    <SUMMARY>
      <p>
        <!-- You must use correct spelling in your comments, -->
        <!-- and most importantly in your identifiers. -->
        コメントでは正しい綴りを用いなければなりません。とりわけ識別子では正しい綴りが重要になります。
      </p>
      <p>
        <!-- When several correct spellings exist (including American vs English), -->
        <!-- and there isn't a consensus amongst developers as which to use, -->
        <!-- you should choose the shorter spelling. -->
        複数の正しい綴りが存在する場合(米国式綴り vs 英国式綴り)で、
        開発者間でどちらの綴りを採用するかのコンセンサスが存在していない場合、短い方の綴りを採用するべきです。
      </p>
      <p>
        <!-- You must use only common and domain-specific abbreviations, and -->
        <!-- must be consistent with these abbreviations.  You may abbreviate -->
        <!-- lexical variables of limited scope in order to avoid overly-long -->
        <!-- symbol names.  -->
        略語は、良く使われるものか、分野に特化したものだけを利用するようにしなければなりません。
        また、それらの略語には一貫性を持たせなくてはなりません。
        スコープが限定されたレキシカル変数の名前では、長すぎる名前を避けるために名前を略しても良いでしょう。
      </p>
    </SUMMARY>
    <BODY>
      <p>
        <!-- If you're not sure, consult a dictionary, -->
        <!-- Google for alternative spellings, -->
        <!-- or ask a local expert. -->
        不確かな場合、辞書で調べたり、他の綴りがないかGoogleで検索したり、近くの詳しい人に訊きましょう。
      </p>
      <p>
        <!-- Here are examples of choosing the correct spelling: -->
        下記に正しい綴りの選択例を挙げます:
      </p>
      <ul>
        <li>
          <!-- Use "complimentary" in the sense of a meal or beverage -->
          <!-- that is not paid for by the recipient, not "complementary". -->
          "complimentary"は、受給者が無料でドリンクや、食べ物を得るようなことに使う。
	  "complementary"(補足的な)ではない。
        </li>
        <li>
          <!-- Use "existent" and "nonexistent", not "existant". -->
          <!-- Use "existence", not "existance". -->
          "existent"(実在する)か"nonexistent"(存在しない)を使い、"existant"という綴りは使わない。
          "existence"と綴り、"existance"とは綴らない。
        </li>
        <li>
          <!-- Use "hierarchy" not "heirarchy". -->
          "hierarchy"と綴り、"heirarchy"とは綴らない。
        </li>
        <li>
          <!-- Use "precede" not "preceed". -->
          "precede"と綴り、"preceed"とは綴らない。
        </li>
        <li>
          <!-- Use "weird", not "wierd". -->
          "weird"と綴り、"wierd"とは綴らない。
        </li>
      </ul>
      <p>
        <!-- Here are examples of choosing the shorter spelling: -->
        下記は、短い綴りの採択例です:
      </p>
      <ul>
        <li>
          <!-- Use "canceled", not "cancelled" -->
          "canceled"と綴り、"cancelled"とは綴らない。
        </li>
        <li>
          <!-- Use "queuing", not "queueing". -->
          "queuing"と綴り、"queueing"とは綴らない。
        </li>
        <li>
          <!-- Use "signaled", not "signalled"; -->
          "signaled"と綴り、"signalled"とは綴らない。
        </li>
        <li>
          <!-- Use "traveled", not "travelled". -->
          "traveled"と綴り、"travelled"とは綴らない。
        </li>
        <li>
          <!-- Use "aluminum", not "aluminium" -->
          "aluminum"と綴り、"aluminium"とは綴らない。
        </li>
        <li>
          <!-- Use "oriented", not "orientated" -->
          "oriented"と綴り、"orientated"とは綴らない。
        </li>
        <li>
          <!-- Use "color", not "colour" -->
          "color"と綴り、"colour"とは綴らない。
        </li>
        <li>
          <!-- Use "behavior", not "behaviour" -->
          "behavior"と綴り、"behaviour"とは綴らない。
        </li>
      </ul>
      <p>
        <!-- Make appropriate exceptions for industry standard nomenclature/jargon, -->
        <!-- including plain misspellings. -->
        <!-- For instance: -->
        工業的な述語/ジャーゴン(単なる綴り間違いも含む)は適切に例外として扱います。
        例えば:
      </p>
      <ul>
        <li>
          <!-- Use "referer", not "referrer", in the context of the HTTP protocol. -->
          HTTPプロトコルの文脈では、"referer"と綴り、"referrer"とは綴らない。
        </li>
      </ul>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="行の長さ"><!-- Line length -->
    <SUMMARY>
      <!-- You should format source code so that no line is longer than 100 characters. -->
      あなたはソースコードの中に100文字を超える行がないように整形すべきです。
    </SUMMARY>
    <BODY>
      <p>
        <!-- Some line length restriction is better than none at all. -->
	いくつかの行の長さについての制限はないよりはましです。
        <!-- While old text terminals used to make 80 columns the standard, -->
        <!-- these days, allowing 100 columns seems better, -->
        <!-- since good style encourages the use of -->
        <!-- descriptive variables and function names. -->
	100文字の制限は、その意味を示した変数や関数の名前を使う、
	良い姿勢へと誘導します。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="字下げ"><!-- Indentation -->
    <SUMMARY>
      <p>
        <!-- Indent your code the way a properly configured GNU Emacs does. -->
	コードの字下げはGNU Emacsにあらかじめ設定されている値に従います。
      </p>
      <p>
        <!-- Indent carefully to make the code easier to understand. -->
	コードの理解を簡単にするため、字下げは慎重に行います。
      </p>
    </SUMMARY>
    <BODY>
      <p>
        <!-- By default, GNU Emacs does an excellent job indenting Common Lisp code. -->
	GNU EmacsはCommon Lispのコードの字下げについて、初期設定のままで素晴らしい仕事をします。
        <!-- It can be taught how to indent new defining forms -->
        <!-- and special rules for domain specific languages. -->
	新しい定義形式やドメイン固有言語のための特別なルールを教えることもできます。
        <!-- Each project may have some file to customize indentation; use it. -->
	それぞれのプロジェクトがカスタマイズされた字下げのルールを記したファイルを持っている場合もありますが、
	その際はそれを使います。
      </p>
      
      
      <p>
        <!-- Use indentation to make complex function applications easier to read. -->
	字下げは、複雑な機能を持ったアプリケーションを簡単に読めるようにするために使われます。
        <!-- When an application does not fit on one line -->
        <!-- or the function takes many arguments, -->
        <!-- consider inserting newlines between the arguments -->
        <!-- so that each one is on a separate line. -->
	アプリケーションが一行に収まらないときや、関数が数多くの引数をとるとき、
	引数と引数の間に開業をいれ、それぞれを分割された行に収めることを考えます。
        <!-- However, do not insert newlines in a way that makes it hard to tell -->
        <!-- how many arguments the function takes -->
        <!-- or where an argument form starts and ends. -->
	しかし、改行を関数がいくつの引数をとるのかわかりづらくするような位置に入れたり、
	引数リストの最初や最後にいれてはなりません。
      </p>
      <BAD_CODE_SNIPPET>
        <!-- ;; Bad -->
        ;; 悪い例
        (do-something first-argument second-argument (lambda (x)
            (frob x)) fourth-argument last-argument)
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        <!-- ;; Better -->
        ;; 良い例
        (do-something first-argument
                      second-argument
                      #'(lambda (x) (frob x))
                      fourth-argument
                      last-argument)
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="ファイルヘッダ">
    <SUMMARY>
      <p>
        <!-- You should include a description at the top of each source file.  -->
        各々のソースファイルの先頭には、説明書きを含めるべきです。
      </p>
      <p>
        <!-- You should include neither authorship nor copyright information in a source file.  -->
	ソースファイルには、作者情報や著作権情報は含めるべきではありません。
      </p>
    </SUMMARY>
    <BODY>
      <p>
        <!-- Every source file should begin with a brief description -->
        <!-- of the contents of that file.  -->
	すべてのソースファイルにおいて、ファイルの要約された説明書きが先頭にあるべきです。
      </p>
      <p>
        <!-- After that description, every file should start the code itself with an -->
        <!-- <code>(in-package :<em>package-name</em>)</code> form. -->
	説明書きの後には、どのファイルのコード記述も
        <code>(in-package :<em>package-name</em>)</code>フォームで
	開始すべきです。
      </p>
      <p>
        <!-- After that <code>in-package</code> form, -->
        <!-- every file should follow with any file-specific -->
        <!-- <code>(declaim (optimize ...))</code> declaration -->
        <!-- that is not covered by an asdf <code>:around-compile</code> hook. -->
	すべてのファイルは、<code>in-package</code>フォームのあとに、
	asdf <code>:around-compile</code>が関与しない、
	ファイル固有の
        <code>(declaim (optimize ...))</code>などの形式で行われる宣言を記すべきです。
      </p>
      <CODE_SNIPPET>
        ;;;; Author: brown (Robert Brown)

        ;;;; Variable length encoding for integers and floating point numbers.

        (in-package #:varint)
        (declaim #.*optimize-default*)
      </CODE_SNIPPET>
      <p>
        You should not include authorship information at the top of a file,
        that information is available from version control and
        <code>OWNERS</code>. 
        ファイルの先頭には作者情報を含めるべきではありません。
        これは、バージョンコントロールシステムや、<code>OWNERS</code>ファイルから得るような情報の類です。
      </p>
      <p>
        <!-- You should not include copyright information in individual source code files. -->
        <!-- An exception is made for files meant to be disseminated as standalone. -->
	あなたはそれぞれのソースコードファイルに対して著作権表示を含めるべきではありません。
	この例外はファイルを単体で配布することを予定して作っているときです。
      </p>
      <p>
        <!-- Each project or library has a single file specifying its license. -->
        <!-- Absence of a <tt>LICENSE</tt> or <tt>COPYING</tt> file -->
        <!-- means the project is proprietary code. -->
	それぞれのプロジェクトとライブラリにはその固有のライセンスを記した単体のファイルを含めます。
	<tt>LICENSE</tt>あるいは<tt>COPYING</tt>というファイルがない場合はそのプロジェクトが独占的なものであることを示します。
      </p>
      
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="Vertical white space"> -->
  <STYLEPOINT title="空行">
    <SUMMARY>
      <!-- Vertical white space: one blank line between top-level forms. -->
      空行: トップレベルの式は空行一つで隔てられます。
    </SUMMARY>
    <BODY>
      <p>
        <!-- You should include one blank line between top-level forms, -->
        <!-- such as function definitions. -->
	あなたは、関数定義のようなトップレベルフォームを、空行一つで隔てるべきです。
        <!-- Exceptionally, blank lines can be omitted -->
        <!-- between simple, closely related defining forms of the same kind, -->
        <!-- such as a group of related type declarations or constant definitions. -->
	型宣言や定数宣言のような単純で、近しい関係にある同等の定義が隣り合う場合は、例外的に一行の空行を入れなくてもかまいません。
      </p>
      <CODE_SNIPPET>
        (defconstant +mix32+ #x12b9b0a1 "pi, an arbitrary number")
        (defconstant +mix64+ #x2b992ddfa23249d6 "more digits of pi")

        (defconstant +golden-ratio32+ #x9e3779b9 "the golden ratio")
        (defconstant +golden-ratio64+ #xe08c1d668b756f82 "more digits of the golden ratio")

        (defmacro incf32 (x y)
          "Like INCF, but for integers modulo 2**32"
          `(setf ,x (logand (+ ,x ,y) #xffffffff)))
        (defmacro incf64 (x y)
          "Like INCF, but for integers modulo 2**64"
          `(setf ,x (logand (+ ,x ,y) #xffffffffffffffff)))
      </CODE_SNIPPET>
      <p>
        <!-- Blank lines can be used to separate parts of a complicated function. -->
	空行は複雑な関数をいくつかに分解するためにも有用です。
        <!-- Generally, however, you should break a large function into smaller ones -->
        <!-- instead of trying to make it more readable by adding vertical space. -->
        <!-- If you can't, you should document with a <code>;;</code> comment -->
        <!-- what each of the separated parts of the function does. -->
	しかしながら、あなたは、総じて巨大な関数は小さな関数に割ってやり、より読みやすいように、
	縦方向の空白を追加して読みやすくすべきです。
	あなたにそれができない場合は、あなたは<code>;;</code>で始まるコメントを
	関数のそれぞれの分割点に書き残すべきです。
      </p>
      <p>
        <!-- Every top-level form -->
        <!-- should be fewer than 61 lines long, -->
        <!-- including comments but excluding the documentation string. -->
	すべてのトップレベルフォームはコメントを含め、docstringを除いて61行以下に収めるべきです。
        <!-- This applies to each of the forms in an <code>eval-when</code>, -->
        <!-- rather than to the <code>eval-when</code> itself. -->
        <!-- Additionally, <code>defpackage</code> forms may be longer, -->
        <!-- since they may include long lists of symbols. -->
	これは一つの<code>eval-when</code>それ自体ではなくて
	<code>eval-when</code>のなかに含まれたそれぞれのフォームに
	適用されます。また、<code>defpackage</code>フォームは
	長いシンボルのリストを含めるため、これよりも長くなります。
      </p>
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="Horizontal white space"> -->
  <STYLEPOINT title="水平方向の空白">
    <SUMMARY>
      <!-- Horizontal white space: none around parentheses. No tabs. -->
      水平方向の空白: 括弧を空白で包んだりはしません。タブ文字の利用もしません。
    </SUMMARY>
    <BODY>
      <p>
        <!-- You must not include extra horizontal whitespace -->
        <!-- before or after parentheses or around symbols. -->
	あなたは、余計な水平方向の空白を括弧やシンボルの間には含めてはなりません。
      </p>
      <p>
        <!-- You must not place right parentheses by themselves on a line. -->
        <!-- A set of consecutive trailing parentheses must appear on the same line. -->
	あなたは右括弧のためだけの行を設けてはなりません。
	連続する括弧は同じ行に収めなければなりません。

      </p>
      <BAD_CODE_SNIPPET>
        <!-- ;; Very Bad -->
        ;; 酷すぎる例
        ( defun factorial ( limit )
          ( let (( product 1 ))
            ( loop for i from 1 upto limit
                  do (setf product ( * product i ) ) )
            product
          )
        )
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        <!-- ;; Better -->
        ;; 良い例
        (defun factorial (limit)
          (let ((product 1))
            (loop for i from 1 upto limit
                  do (setf product (* product i)))
            product))
      </CODE_SNIPPET>
      <p>
        <!-- You should use only one space between forms. -->
	あなたはフォームを一つの空白で隔てるべきです。
      </p>
      <p>
        <!-- You should not use spaces to vertically align forms -->
        <!-- in the middle of consecutive lines. -->
	あなたは行の間に縦方向にフォームを揃えるために空白を挿入すべきではありません。
        <!-- An exception is made when the code possesses -->
        <!-- an important yet otherwise not visible symmetry -->
        <!-- that you want to emphasize. -->
	これについての例外はコードの支配をするために見えない対称性を強調することを、
	あなたが重要視するときです。
      </p>
      <BAD_CODE_SNIPPET>
        <!-- ;; Bad -->
        ;; 悪い例
        (let* ((low    1)
               (high   2)
               (sum    (+ (* low low) (* high high))))
          ...)
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        <!-- ;; Better -->
        ;; 良い例
        (let* ((low 1)
               (high 2)
               (sum (+ (* low low) (* high high))))
          ...))
      </CODE_SNIPPET>
      <p>
        <!-- You must align nested forms if they occur across more than one line. -->
	あなたは入れ子になったフォームが複数行にわたるとき、これを縦揃えしなければなりません。
      </p>
      <BAD_CODE_SNIPPET>
        <!-- ;; Bad -->
        ;; 悪い例
        (defun munge (a b c)
        (* (+ a b)
        c))
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        <!-- ;; Better -->
        ;; 良い例
        (defun munge (a b c)
          (* (+ a b)
             c))
      </CODE_SNIPPET>
      <p>
        <!-- The convention is that the body of a binding form -->
        <!-- is indented two spaces after the form. -->
	慣例では変数束縛のフォームのあと、二つの空白で字下げします。
        <!-- Any binding data before the body is usually indented four spaces. -->
	値の束縛を行うフォームは通常四つの空白で字下げします。
        <!-- Arguments to a function call are aligned with the first argument; -->
        <!-- if the first argument is on its own line, -->
        <!-- it is aligned with the function name. -->
	関数呼び出しの引数は最初の引数の位置で縦揃えします。
	もし、最初の引数が、関数名の行に存在しない場合は、関数名で縦揃えします。
      </p>
      <CODE_SNIPPET>
        (multiple-value-bind (a b c d)
            (function-returning-four-values x y)
          (declare (ignore c))
          (something-using a)
          (also-using b d))
      </CODE_SNIPPET>
      <p>
        <!-- An exception to the rule against lonely parentheses -->
        <!-- is made for an <code>eval-when</code> form around several definitions; -->
        <!-- in this case, include a comment <code>; eval-when</code> -->
        <!-- after the closing parenthesis. -->
	括弧を単体で行においてはならないルールの例外は
	いくつかの定義をくるんだ<code>eval-when</code>フォームを置いたことによって
	括弧が単体で行に置かれる場合です。
	この場合、閉じ括弧の行に <code>; eval-when</code>を記しておきます。
      </p>
      <p>
        <!-- You must set your editor to -->
        <!-- avoid inserting tab characters in the files you edit. -->
	あなたはあなたが編集するファイルにタブ文字が挿入されることを防ぐために、
	エディタを設定しなければなりません。
        <!-- Tabs cause confusion when editors disagree -->
        <!-- on how many spaces they represent. -->
        <!-- In Emacs, do <code>(setq-default indent-tabs-mode nil)</code>. -->
	タブはエディタによって表現するために使用される空白の個数が違うため、
	混乱を引き起こします。
        Emacsにおいては<code>(setq-default indent-tabs-mode nil)</code>を実行すれば、
	この問題を回避できます。
      </p>
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<CATEGORY title="文書化"><!-- Documentation -->
  <STYLEPOINT title=""><!-- Document everything -->
    <SUMMARY>
      <!-- You should use document strings on all visible functions -->
      <!-- to explain how to use your code. -->
      あなたはあなたのコードの使い方について説明するために、すべての見える関数に対して文書化用文字列を使うべきです。
    </SUMMARY>
    <BODY>
      <p>
        <!-- Unless some bit of code is painfully self-explanatory, -->
        <!-- document it with a documentation string (also known as docstring). -->
	それ自体が十分すぎる自己の解説になっているような、いくつかのコード片は除いて、
	それについて（docstringとして知られている）文書化用文字列で文書化します。
      </p>
      <p>
        <!-- Documentation strings are destined to be read -->
        <!-- by the programmers who use your code. -->
	文書化用文字列はあなたのコードを使うプログラマ達が読むためのものです。
        <!-- They can be extracted from functions, types, classes, variables and macros, -->
        <!-- and displayed by programming tools, such as IDEs, -->
        <!-- or by REPL queries such as <code>(describe 'foo)</code>; -->
	文書化用文字列は関数や型、クラス、変数及びマクロから切り出すことができ、IDEのような開発ツールで表示させたり、
	REPLにおいて<code>(describe 'foo)</code>といった
	クエリを発行して利用することができます。
        <!-- web-based documentation or other reference works -->
        <!-- can be created based on them. -->
	Webベースの文書やその他の手引きも文書化用文字列から作り出すことができます。
        <!-- Documentation strings are thus the perfect locus to document your API. -->
	文書化用文字列はそれ故、あなたのAPIの完全な指標となります。
        <!-- They should describe how to use the code -->
        <!-- (including what pitfalls to avoid), -->
        <!-- as opposed to how the code works (and where more work is needed), -->
        <!-- which is what you'll put in comments. -->
	文書化用文字列は、（落とし穴の回避方法を含んだ）コードの使い方について解説すべきであり、
	コードがどう働くかということ（それから必要なその他のこと）を書く、コメントとは対照的です。
      </p>
      <p>
        <!-- Supply a documentation string when defining -->
        <!-- top-level functions, types, classes, variables and macros. -->
	（docstringのような）文書化用文字列は、トップレベル関数や、型、クラスおよびマクロの定義時に供給されます。

        <!-- Generally, add a documentation string wherever the language allows. -->
	総合的に、どんな言語でも文書化用文字列は追加できます。
      </p>
      <p>
        <!-- For functions, the docstring should describe the function's contract: -->
        <!-- what the function does, -->
        <!-- what the arguments mean, -->
        <!-- what values are returned, -->
        <!-- what conditions the function can signal. -->
	関数のためのdocstringはその関数が、
	この関数は何をするのか、
	引数は何を意味するのか、
	どんな値が返ってくるのか、
	関数はどんなコンディションを発信するのか、
	について説明すべきです。
        <!-- It should be expressed at the appropriate level of abstraction, -->
        <!-- explaining the intended meaning rather than, say, just the syntax. -->
        <!-- In documentation strings, capitalize the names of Lisp symbols, -->
        <!-- such as function arguments. -->
	これは適切な抽象化レベルにおいて表現されるべきで、
	単なる文法を述べるのではなく、何をするためのものかということを説明すべきです。
	文書文字列のなかにおいては、関数の引数のような、Lispシンボルは大文字にします。
        <!-- For example, "The value of LENGTH should be an integer." -->
        例えば、 "LENGTHの値は整数値であるべきです。"といった具合です。
      </p>
      <CODE_SNIPPET>
        (defun small-prime-number-p (n)
          <!-- "Return T if N, an integer, is a prime number. Otherwise, return NIL." -->
          "Nが整数でかつ素数ならTが返ります。そうでない場合はNILが返ります。"
          (cond ((or (&lt; n 2))
                 nil)
                ((= n 2)
                 t)
                ((divisorp 2 n)
                 nil)
                (t
                 (loop for i from 3 upto (sqrt n) by 2
                       never (divisorp i n)))))
      </CODE_SNIPPET>
      <CODE_SNIPPET>
        (defgeneric table-clear (table)
          (:documentation
            "Like clrhash, empties the TABLE of all
            associations, and returns the table itself."))
      </CODE_SNIPPET>
      <p>
        <!-- A long docstring may usefully -->
        <!-- begin with a short, single-sentence summary, -->
        <!-- followed by the larger body of the docstring. -->
	長いDocstringは、短い、そのあとに続くdocstringの概要を示す単文で始めることで便利になります。
      </p>
      <p>
        <!-- When the name of a type is used, -->
        <!-- the symbol may be quoted by surrounding it with -->
        <!-- a back quote at the beginning and a single quote at the end. -->
	型の名前を使うときはバッククォートを名前の最初におき、最後に単一引用符をおいて囲んでやります。
        <!-- Emacs will highlight the type, and the highlighting serves -->
        <!-- as a cue to the reader that <kbd>M-.</kbd> -->
        <!-- will lead to the symbol's definition. -->
	Emacsは型をハイライトし、ハイライトされた部分でキーバインド<kbd>M-.</kbd>を実行することで、
	シンボルの定義部へと導いてくれます。
      </p>
      <CODE_SNIPPET>
        (defun bag-tag-expected-itinerary (bag-tag)
          "Return a list of `legacy-pnr-pax-segment' objects representing
          the expected itinerary of the `bag-tag' object, BAG-TAG."
          ...)
      </CODE_SNIPPET>
      <p>
        <!-- Every method of a generic function should be independently documented -->
        <!-- when the specialization affects what the method does, -->
        <!-- beyond what is described in its generic function's docstring. -->
	総称関数におけるすべてのメソッドにおいては、それぞれの特殊化された場合において
	メソッドが何をするかということを、その総称関数のdocstringに書かれていないより詳しい点について、
	個別に文書化されるべきです。
      </p>
      <p>
        <!-- When you fix a bug, -->
        <!-- consider whether what the fixed code does is obviously correct or not; -->
	バグを修正するときは、その修正がはっきりと正しいかそうではないか考えます。
        <!-- if not, you must add a comment explaining -->
        <!-- the reason for the code in terms of fixing the bug. -->
	もしそうではないなら、あなたはバグを修正するためにそのコードを用いた理由を説明するコメントを
	追加しなければなりません。
        <!-- Adding the bug number, if any, is also recommended. -->
	もしバグ番号があるならそれも追加します。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="コメントのセミコロン"><!-- Comment semicolons -->
    <SUMMARY>
      <!-- You must use the appropriate number of semicolons to introduce comments. -->
      あなたは、適切な数のセミコロンでコメントを開始しなくてはなりません。
    </SUMMARY>
    <BODY>
       <p>
        <!-- Comments are explanations to the future maintainers of the code. -->
	コメントは将来保守する人のための説明です。
        <!-- Even if you're the only person who will ever see and touch the code, -->
        <!-- even if you're either immortal and never going to quit, -->
        <!-- or unconcerned with what happens after you leave -->
        <!-- (and have your code self-destruct in such an eventuality), -->
        <!-- you may find it useful to comment your code. -->
	他の人が触らないと分っているコードでも、仮にあなたが不死身で[開発を]やめない、
	あるいは自分が離れたあとどうなるか気にしない(そして結局コードは読めなくなる)場合でも、
	コメントは有用であると気づくでしょう。
        <!-- Indeed, by the time you revisit your code, -->
        <!-- weeks, months or years later, -->
        <!-- you will find yourself a different person from the one who wrote it, -->
        <!-- and you will be grateful to that previous self -->
        <!-- for making the code readable. -->
	実際、何週間、何ヶ月、あるいは何年か経って自分のコードを再度読んだときにはコードを書いたときとは他人になっていて、
	あのときの自分が読み易いコードを書いてくれたことに感謝することになるでしょう。
      </p>
      <p>
        <!-- You must comment anything complicated -->
        <!-- so that the next developer can understand what's going on. -->
        <!-- (Again, the "hit by a truck" principle.) -->
	次の開発者が何をしているのか分かるように複雑なものには全てコメントを残す必要があります。
	(「トラックにはねられたらの原理」を思い出しましょう。)
      </p>
      <p>
        <!-- Also use comments as a way to guide those who read the code, -->
        <!-- so they know what to find where. -->
	何がどこにあるのかの案内としてもコメントを使いましょう。
      </p>
      <ul>
        <li>
          <!-- File headers and important comments -->
          <!-- that apply to large sections of code in a source file -->
          <!-- should begin with four semicolons. -->
	  ファイルヘッダやソースファイル中のコードの巨大な領域に適用される重要なコメントは、
	  四つのセミコロンで始めるべきです。
        </li>
        <li>
          <!-- You should use three semicolons -->
          <!-- to begin comments that apply to just -->
          <!-- one top-level form or small group of top-level forms. -->
	  あなたは、一つのトップレベルフォームや、トップレベルフォームの小さな集合に適用されるコメントを、
	  三つのセミコロンで始めるべきです。
        </li>
        <li>
          <!-- Inside a top-level form, you should use two semicolons -->
          <!-- to begin a comment if it appears between lines. -->
	  トップレベルフォームの中において、行と行の間でコメントを開始するときは、
	  二つのセミコロンで開始すべきです。
        </li>
        <li>
          <!-- You should use one semicolon if it is a parenthetical remark -->
          <!-- and occurs at the end of a line. -->
	  あなたは行末において補足的な情報を含めたい時に一つのセミコロンを使うべきです。
          <!-- You should use spaces to separate the comment -->
          <!-- from the code it refers to so the comment stands out. -->
	  あなたはコメントを空白を使って関連するコードから目立つように分離すべきです。
          <!-- You should try to vertically align -->
          <!-- consecutive related end-of-line comments. -->
	  あなたは連続する行末コメントを縦揃えすることを試みるべきです。
        </li>
      </ul>
      <CODE_SNIPPET>
        ;;;; project-euler.lisp
        <!-- ;;;; File-level comments or comments for large sections of code. -->
	;;;; ファイルレベルでのコメントや大きなセクションのコメント。
        <!-- ;;; Problems are described in more detail here:  http://projecteuler.net/ -->
	;;; 詳細はこちらにあります:  http://projecteuler.net/
        <!-- ;;; Divisibility -->
	;;; 可分性[dでnをわりきれるか]
        <!-- ;;; Comments that describe a group of definitions. -->
	;;; 一群のコードに対するコメント
        (defun divisorp (d n)
          (zerop (mod n d)))

        (defun proper-divisors (n)
          ...)

        (defun divisors (n)
          (cons n (proper-divisors n)))

        <!-- ;;; Prime numbers -->
	;;; 素数

        (defun small-prime-number-p (n)
          (cond ((or (&lt; n 2))
                 nil)
                ((= n 2)   ; 行末の補足はここに<!-- ; parenthetical remark here -->
                 t)        ; 補足の続き<!-- ; continuation of the remark -->
                ((divisorp n 2)
                 nil)  ; 別の補足<!-- ; different remark -->
                <!-- ;; Comment that applies to a section of code. -->
		;; コードの一部に対するコメント
		<!--sectionは「一部」の意味と「ある程度まとまった」の意味を帯びているのだと思いますが、適当な日本語が思いつきませんでした(κeen)-->
                (t
                 (loop for i from 3 upto (sqrt n) by 2
                       never (divisorp i n)))))
      </CODE_SNIPPET>
      <p>
        <!-- You should include a space between the semicolon and the text of the comment. -->
	コメントのセミコロンと文章の間には一つ空白が入るべきです。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="文法と句読点"><!-- Grammar and punctuation -->
    <SUMMARY>
      You should punctuate documentation correctly.
    </SUMMARY>
    <BODY>
      <p>
        <!-- When a comment is a full sentence, -->
        <!-- you should capitalize the initial letter of the first word -->
        <!-- and end the comment with a period. -->
	コメントの全文において、あなたは最初の単語の最初の文字を大文字にして、
	コメントの最後をピリオドで終えるべきです。
        <!-- In general, you should use correct punctuation. -->
	総合的に、あなたは句読点について校正を行うべきです。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="注目の集め方"><!-- Attention Required -->
    <SUMMARY>
      <!-- You must follow the convention of using TODO comments -->
      <!-- for code requiring special attention. -->
      <!-- For code using unobvious forms, you must include a comment.  -->
      コードが特に要注意である場合、TODOコメントを使う流儀に従わなければなりせん。
      コードが自明でない書き方の場合、コメントを含めなくてはなりません。
    </SUMMARY>
    <BODY>
      <p>
        <!-- Use TODO comments when the code is known to be incomplete -->
        <!-- and you want to indicate what work remains to be done. -->
	TODOコメントは既知の未完了のコードがあって、あなたがそれを忘れないように
	示しておきたいときに使います。
        <!-- For comments requiring special attention, such as -->
        <!-- incomplete code, todo items, questions, breakage, and danger, -->
        <!-- include a TODO comment indicating the type of problem, -->
        <!-- its nature, and any notes on how it may be addressed.  -->
        コメントのうち、特別な注意が必要なもの(不完全なコード・TODOアイテム・疑問・破損・危険箇所等)
        は、TODOコメントに、その問題のタイプと性質や、どのように問題に取り組めるかを、含めましょう。
      </p>
      <p>
        <!-- The comments begin with <code>TODO</code> in all capital letters, -->
        <!-- followed by your email address or other identifier in parentheses, -->
        <!-- followed by a colon, a space, and -->
        <!-- an explanation of what additional work is desirable or required. -->
	コメントはすべて大文字の<code>TODO</code>で始めて、
	あなたのEメールアドレスかその他識別に使えるIDを括弧の中に収め、
	コロンと空白に続けて、望ましいあるいは要求している作業についての説明を書きます。
        <!-- The user name included in the comment is that -->
        <!-- of a person who understands the deficiency. -->
	ユーザ名をコメント内に含めるのは、誰が求めているかを明らかにするためです。
        <!-- A TODO comment is not a commitment to fix the problem. -->
	TODOコメントは問題が修正されるという公約ではありません。
      </p>
      <p>
        <!-- When signing comments, -->
        <!-- you should use your username (for code within the company) -->
        <!-- or full email address (for code visible outside the company), -->
        <!-- not just initials. -->
        コメントに署名する際は、あなたはユーザ名（コードが会社内のものである場合）あるいは、
	Eメールアドレス（コードが社内からでも見られる場合）を使い、イニシャルを使うべきではありません。
      </p>
      <CODE_SNIPPET>
        ;;--- TODO(george@gmail.com): Refactor to provide a better API.
      </CODE_SNIPPET>
      <p>
        Be specific when indicating times or software releases
        in a TODO comment:
      </p>
      <CODE_SNIPPET>
        ;;--- TODO(brown): Remove this code after release 1.7 or before November, 2012.
      </CODE_SNIPPET>
      <p>
        <!-- For code that uses unobvious forms to accomplish a task, you must include a comment -->
        <!-- stating the purpose of the form and the task it accomplishes. -->
        タスクを遂行するために自明でない書き方を採用したコードには、
        その書き方を利用した狙いと、それが遂行することについてをコメントに含めなければなりません。
      </p> 
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="ドメイン固有言語(DSL)"><!-- Domain-Specific Languages -->
    <SUMMARY>
      <!-- You should document DSLs and -->
      <!-- any terse program in a DSL. -->
      あなたはDSLとDSLによって書かれた簡潔なプログラムについて文書化すべきです。
    </SUMMARY>
    <BODY>
      <p>
        <!-- You should design your Domain Specific Language -->
        <!-- to be easy to read and understand by people familiar with the domain. -->
	あなたはあなたのドメイン固有言語を同じような仕事をする人々にとって簡単に読めて理解できるよう
	設計すべきです。
      </p>
      <p>
        <!-- You must properly document all your Domain Specific Language. -->
	あなたはあなたのドメイン固有言語について徹底的に文書化しなければなりません。
      </p>
      <p>
        <!-- Sometimes, your DSL is designed for terseness. -->
	ときにあなたのDSLは無愛想に設計されています。
        <!-- In that case, it is important to document what each program does, -->
        <!-- if it's not painfully obvious from the context. -->
	そのような場合は、文脈から自明のことは除いて、
	それぞれのプログラムの為すことについて重要な点を文書化してください。
      </p>
      <p>
        <!-- Notably, when you use regular expressions -->
        <!-- (e.g. with the <code>CL-PPCRE</code> package), -->
        <!-- you MUST ALWAYS put in a comment -->
        <!-- (usually a two-semicolon comment on the previous line) -->
        <!-- explaining, at least basically, what the regular expression does, -->
        <!-- or what the purpose of using it is. -->
	特に、あなたは正規表現（例えば<code>CL-PPCRE</code>パッケージ）を使うとき、
	あなたは、いつも、
	最低限基本的な部分について正規表現がなにを為すのかあるいはそれをどのような用途に供するのか、
	（前の行に二つのセミコロンを入れたコメントを使って）コメントを入れなければなりません。
        <!-- The comment need not spell out every bit of the syntax, but -->
        <!-- it should be possible for someone to follow the logic of the code -->
        <!-- without actually parsing the regular expression. -->
	このコメントは文法の一つ一つを子細に説明する必要はありませんが、
	実際に正規表現をパーズすることなく、誰かがコードの論理を追うには十分であるべきです。
      </p>
    </BODY>
  </STYLEPOINT>

</CATEGORY>

<!-- <CATEGORY title="Naming"> -->
<CATEGORY title="命名">
  <!-- <STYLEPOINT title="Symbol guidelines"> -->
  <STYLEPOINT title="シンボル書法のガイドライン">
    <SUMMARY>
      <!-- You should use lower case. -->
      <!-- You should not abbreviate. -->
      <!-- You should follow the rules for <a href="#Spelling">Spelling and Abbreviations</a> -->
      <!-- You should follow punctuation conventions. -->
      小文字を用いるべきです。
      略語は<a href="#Spelling">綴りと略語</a>のルールに従うべきです。
      句読点法の慣習には従うべきです。
    </SUMMARY>
    <BODY>
      <p>
        <!-- Use lower case for all symbols. -->
        <!-- Consistently using lower case makes searching for symbol names easier -->
        <!-- and is more readable. -->
	すべてのシンボルにおいて小文字を使います。
	一貫して小文字を使うことで、シンボル名を探しやすくし、より読みやすくします。
      </p>
      <p>
        <!-- Note that Common Lisp is case-converting, -->
        <!-- and that the <code>symbol-name</code> of your symbols -->
        <!-- will be upper case. -->
	気に留めておくべき点として、Common Lispは大文字小文字変換を行い、あなたのシンボルの<code>symbol-name</code>は、
	大文字になるということがあります。
        <!-- Because of this case-converting, -->
        <!-- attempts to distinguish symbols by case are defeated, -->
        <!-- and only result in confusion. -->
	これは大文字小文字変換によるもので、
	シンボルを大文字や小文字によって識別することを困難にし、結果的に混乱を引き起こします。
        <!-- While it is possible to escape characters in symbols -->
        <!-- to force lower case, -->
        <!-- you should not use this capability -->
        <!-- unless this is somehow necessary -->
        <!-- to interoperate with third-party software. -->
	シンボル内の文字をエスケープして強制的に小文字にすることができますが、
	あなたはどうにかして第三者によるソフトウェアを補完するために必要な場合を除いて、
	これをすべきではありません。
      </p>
      <p>
        <!-- Place hyphens between all the words in a symbol. -->
	シンボル内の単語と単語の間にはハイフンを置きます。
        <!-- If you can't easily say an identifier out loud, -->
        <!-- it is probably badly named. -->
	もしあなたが識別子を大声で読み上げることができないのなら、おそらくひどい名前がつけられています。
      </p>
      <p>
        <!-- You must not use <code>"/"</code> or <code>"."</code> -->
        <!-- instead of <code>"-"</code> -->
        <!-- unless you have a well-documented overarching reason to, -->
        <!-- and permission from other hackers who review your proposal. -->
        あなたは
	よく文書化されたすべてにおける理由がある場合や、
	あなたの提案を査読した他のハッカーが権限を与えた場合を除いて
	<code>"-"</code>ではなく、<code>"/"</code>や<code>"."</code>を
	使うべきではありません。
      </p>
      <p>
        <!-- See the section on <a href="#Spelling">Spelling and Abbreviations</a> -->
        <!-- for guidelines on using abbreviations.  -->
        略語利用のガイドラインについては、<a href="#Spelling">綴りと略語</a>の章を参照してください。
      </p>
      <BAD_CODE_SNIPPET>
        <!-- ;; Bad -->
	;; 悪い例
        (defvar *default-username* "Ann")
        (defvar *max-widget-cnt* 200)
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        <!-- ;; Better -->
	;; 良い例
        (defvar *default-user-name* "Ann")
        (defvar *maximum-widget-count* 200)
      </CODE_SNIPPET>
      <p>
        <!-- There are conventions in Common Lisp -->
        <!-- for the use of punctuation in symbols. -->
        <!-- You should not use punctuation in symbols outside these conventions. -->
        これはCommon Lispだけの慣例で、シンボル内で句読点を使います。
	あなたはこの慣例の外で、シンボル内に句読点を使うべきではありません。
      </p>
      <p>
        <!-- Unless the scope of a variable is very small, -->
        <!-- do not use overly short names like -->
        <!-- <code>i</code> and <code>zq</code>. -->
	変数のスコープが極端に小さい場合を除いて、
	異様に短い
	<code>i</code>とか<code>zq</code>といった名前を使うべきではありません。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="意図を示して内容を示さない"><!-- Denote intent, not content -->
    <SUMMARY>
      <!-- Name your variables according to their intent, -->
      <!-- not their content. -->
      あなたの変数名は意図から名付けられ、内容から名付けられません。
    </SUMMARY>
    <BODY>
      <p>
        <!-- You should name a variable according -->
        <!-- to the high-level concept that it represents, -->
        <!-- not according to the low-level implementation details -->
        <!-- of how the concept is represented. -->
	あなたは高レベルの概念を低レベルの実装がどう表現するかという
	詳細からではなくて、
	その概念そのものの表現から変数を名付けるべきです。
      </p>
      <p>
        <!-- Thus, you should avoid embedding -->
        <!-- data structure or aggregate type names, -->
        <!-- such as <code>list</code>, <code>array</code>, or -->
        <!-- <code>hash-table</code> inside variable names, -->
        <!-- unless you're writing a generic algorithm that applies to -->
        <!-- arbitrary lists, arrays, hash-tables, etc. -->
	それゆえ、リストや配列やハッシュテーブルに限定的な汎用アルゴリズムを書いているのでもない限り、
	変数名にデータ構造を埋め込んだり、
	<code>list</code>、<code>array</code>、<code>hash-table</code>
	などの型の名前を集約することは避けるべきです。
        <!-- In that case it's perfectly OK to name a variable -->
        <!-- <code>list</code> or <code>array</code>. -->
	逆にそのような場合は<code>list</code>や<code>array</code>などの変数名は望ましいものです。
      </p>
      <p>
        <!-- Indeed, you should be introducing new abstract data types -->
        <!-- with <code>DEFCLASS</code> or <code>DEFTYPE</code>, -->
        <!-- whenever a new kind of intent appears for objects in your protocols. -->
	実際、オブジェクトに新たな意図が出てきたときは<code>DEFCLASS</code>や<code>DEFTYPE</code>
	を使って新たな抽象データ型を導入しているべきです。 <!--protocolを無視しました。どう訳せばいいんだろ…(κeen)-->
        <!-- Functions that manipulate such objects generically may then -->
        <!-- use variables the name of which reflect that abstract type. -->
	そのようなデータ型を汎用的に扱う関数にはその抽象型を反映した変数名を与えても構いません。
      </p>
      <p>
        <!-- For example, if a variable's value is always a row -->
        <!-- (or is either a row or <code>NIL</code>), -->
        <!-- it's good to call it <code>row</code> or <code>first-row</code> -->
        <!-- or something like that. -->
	例えば、もしその変数の値が常に列(row)(あるいは列または<code>NIL</code>)のときは、
	<code>row</code>や<code>first-row</code>などの名前を与えるのが適当でしょう。
        <!-- It is alright is <code>row</code> has been --><!-- 二つめのisはifのミス？ -->
        <!-- <code>DEFTYPE</code>'d to <code>STRING</code> &#8212; -->
        <!-- precisely because you have abstracted the detail away, -->
        <!-- and the remaining salient point is that it is a row. -->
	<code>row</code>が<code>STRING</code>として<code>DEFTYPE</code>されていても全く問題はありません。
	明確にこれは詳細を抽象化し、残された特徴がそれが列であるということだけになっているからです。
        <!-- You should not name the variable <code>STRING</code> in this context, -->
        <!-- except possibly in low-level functions that specifically manipulate -->
        <!-- the innards of rows to provide the suitable abstraction. -->
	この場合、低次の処理が列の内部を処理し、適切に抽象化するのでもない限り、
	変数名を<code>STRING</code>にすべきではありません。
      </p>
      <p>
        <!-- Be consistent. -->
	首尾一貫しましょう。
        <!-- If a variable is named <code>row</code> in one function, -->
        <!-- and its value is being passed to a second function, -->
        <!-- then call it <code>row</code> rather than, say, <code>value</code> -->
        <!-- (this was a real case). -->
	ある関数で<code>row</code>と名付け、その値が別の関数に渡されたのなら例えば<code>value</code>などと呼ばずに
	<code>row</code>と呼びましょう(これは実際にあったことなのです)。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="大域変数と定数"><!-- Global variables and constants -->
    <SUMMARY>
      <!-- Name globals according to convention. -->
      大域変数および定数の命名は慣習に従います。
    </SUMMARY>
    <BODY>
      <p>
        <!-- The names of global constants should start and end -->
        <!-- with plus characters. -->
	大域定数の名前には、ばじめとおわりに+(ブラス記号)をつけるべきです。
      </p>
      <p>
        <!-- Global variable names should start and end with asterisks -->
	大域変数の名前には、はじめとおわりに*(アスタリスク)をつけるべきです。
        <!-- (also known in this context as earmuffs). -->
	(このやり方は耳当てとして知られています。)
      </p>
      <p>
        <!-- In some projects, parameters that are not meant -->
        <!-- to be usually modified or bound under normal circumstances -->
        <!-- (but may be during experimentation or exceptional situations) -->
        <!-- should start (but do not end) with a dollar sign. -->
	いくつかのプロジェクトにおいては、
	通常修正されるべきではないパラメータや、普段は束縛されるべきではないパラメータ
	(ただし、試験や例外的な状況の間かもしれません)
	のはじめ(おわりにはつけない)に$(ドル記号)をつけるべきです。
        <!-- If such a convention exists within your project, -->
        <!-- you should follow it consistently. -->
	こういった慣習があなたのプロジェクトにおいてあるのなら、
	あなたはそれに従うべきです。
        <!-- Otherwise, you should avoid naming variables like this. -->
	一方、あなたは変数をこのように名付けることは避けるべきです。
      </p>
      <p>
        <!-- Common Lisp does not have global lexical variables, -->
        <!-- so a naming convention is used to ensure that globals, -->
        <!-- which are dynamically bound, -->
        <!-- never have names that overlap with local variables. -->
	Common Lispは大域レキシカル変数を持ちません、
	命名についての慣習は大域変数の動的束縛と
	ローカル変数による名前の上書きからの保護を行います。
        <!-- It is possible to fake global lexical variables -->
        <!-- with a differently named global variable -->
        <!-- and a <code>DEFINE-SYMBOL-MACRO</code>. -->
	これは違う名前の大域変数と<code>DEFINE-SYMBOL-MACRO</code>による
	偽りの大域レキシカル変数によって可能になります。
        <!-- You should not use this trick, -->
        <!-- unless you first publish a library that abstracts it away. -->
	あなたが最初にそれを抽象化するライブラリを発行する場合を除いて、
	あなたはこのようなトリックを使うべきではありません。
      </p>
      <CODE_SNIPPET>
        (defconstant +hash-results+ #xbd49d10d10cbee50)

        (defvar *maximum-search-depth* 100)
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="Predicate names"> -->
  <STYLEPOINT title="述語の命名">
    <SUMMARY>
      <!-- Names of predicate functions and variables end with a <code>"P"</code>.  -->
      <code>"P"</code>で終わる述語関数、もしくは変数の名前について
    </SUMMARY>
    <BODY>
      <p>
        <!-- You should name boolean-valued functions and variables with a -->
        <!-- trailing <code>"P"</code> or <code>"-P"</code>,  -->
        <!-- to indicate they are predicates. -->
        <!-- Generally, you should use -->
        <!-- <code>"P"</code> when the rest of the function name is one word -->
        <!-- and <code>"-P"</code> when it is more than one word. -->
        ブール値を返す関数や変数はそれらが述語であることを示すために<code>"P"</code>か<code>"-P"</code>で終わる名前とすべきです。
        一般的に名前が単語の場合は、<code>"P"</code>を使い、複数語の場合は、<code>"-P"</code>を使うべきです。
      </p>
      <p>
        <!-- A rationale for this convention is given in -->
        <!-- <a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node69.html">the CLtL2 chapter on predicates</a>. -->
        この慣習の根拠となるものには、
        <a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node69.html">CLtL2 predicatesの章</a>
        があります。
      </p>
      <p>
        <!-- For uniformity, you should follow the convention above, -->
        <!-- and not one of the alternatives below. -->
        一貫性の為に、上記の慣習にしたがうべきで、下記に挙げる別の慣習には従わないようにすべきです。
      </p>
      <p>
        <!-- An alternative rule used in some existing packages -->
        <!-- is to always use <code>"-P"</code>. -->
        <!-- Another alternative rule used in some existing packages -->
        <!-- is to always use <code>"?"</code>. -->
        <!-- When you develop such a package, -->
        <!-- you must be consistent with the rest of the package. -->
        <!-- When you start a new package, -->
        <!-- you should not use such an alternative rule -->
        <!-- without a very good documented reason. -->
        とある既存のパッケージで使われている別のルールで、常に<code>"-P"</code>を付けるというもの。
        また、とある既存のパッケージで使われている別のルールで、常に<code>"?"</code>を付けるというもの。
        このような[別ルールの命名の]パッケージで開発を行う場合は、パッケージ内の他の箇所との一貫性を維持しなくてはなりません。
        新しいパッケージを作成して始める場合は、かなり良く文書化された理由でもない限り、このような別のルールを用いるべきではありません。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="ライブラリ名の接頭辞は使わない">
    <SUMMARY>
      <!-- You should not include a library or package name -->
      <!-- as a prefix within the name of symbols. -->
      ライブラリやパッケージの名前を接頭辞としてシンボル名に含めないようにするべきです。
    </SUMMARY>
    <BODY>
      <p>
        <!-- When naming a symbol (external or internal) in a package, -->
        パッケージ内でシンボル(外部もしくは内部)シンボルを命名する時は、
        <!-- you should not include the package name -->
        <!-- as a prefix within the name of the symbol. -->
        ライブラリやパッケージの名前を接頭辞としてシンボル名に含めないようにするべきです。
        <!-- Naming a symbol this way makes it awkward to use -->
        <!-- from a client package accessing the symbol -->
        <!-- by qualifying it with a package prefix, -->
        このような(訳注:接頭辞付きの)シンボルの命名は、パッケージを使う側がシンボルを扱う際に、
        パッケージ名が重複して修飾される形になり不恰好なものになります。
        (一つはパッケージ名、一つはシンボルに含まれた接頭辞)
        <!-- where the package name then appears twice -->
        <!-- (once as a package prefix, -->
        <!-- another time as a prefix within the symbol name). -->
      </p>
      <BAD_CODE_SNIPPET>
        ;; 悪い
        (in-package #:varint)
        (defun varint-length64 () ... )

        (in-package #:client-code)
        (defconst +padding+ (varint:varint-length64 +end-token+))
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        ;; より良い
        (in-package #:varint)
        (defun length64 () ... )

        (in-package #:client-code)
        (defconst +padding+ (varint:length64 +end-token+))
      </CODE_SNIPPET>
      <p>
        <!-- An exception to the above rule would be to include a prefix -->
        <!-- for the names of variables that would otherwise be expected to clash -->
        <!-- with variables in packages that use the current one. -->
        上記ルールの例外として、変数名に接頭辞を含めなければ、使われる先で名前が競合してしまうことが予期される場合があります。
        <!-- For instance, <code>ASDF</code> exports a variable <code>*ASDF-VERBOSE*</code> -->
        <!-- that controls the verbosity of <code>ASDF</code> only, -->
        <!-- rather than of the entire Lisp program. -->
        例えば、<code>ASDF</code>は、<code>ASDF</code>の(訳注: メッセージの)冗長さを制御する変数として<code>*ASDF-VERBOSE*</code>(訳注:という名前で)エクスポートしていますが、
        これは、<code>ASDF</code>にだけ作用し、Lispプログラム全体に作用するものではありません<!-- 分かり難いので分割した -g000001 -->(訳注:ので競合しないように命名します)。
      </p>
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="Packages"> -->
  <STYLEPOINT title="パッケージ">
    <SUMMARY>
      <!-- Use packages appropriately. -->
      パッケージは適切に使いましょう。
    </SUMMARY>
    <BODY>
      <p>
        <!-- Lisp packages are used to demarcate namespaces. -->
	Lispのパッケージは名前空間を分離するのに使います。
        <!-- Usually, each system has its own namespace. -->
        普通、それぞれのシステムは自身の名前空間を使います。
	<!-- A package has a set of external symbols, -->
        <!-- which are intended to be used from outside the package, -->
        <!-- in order to allow other modules to use this module's facilities. -->
	パッケージには他のモジュールがこのモジュールの機能を使えるようにパッケージの外から使うことを意図した外部シンボルの集合があります。
      </p>
      <p>
        <!-- The internal symbols of a package -->
        <!-- should never be referred to from other packages. -->
	パッケージの内部シンボルは他のパッケージから参照されるべきではありません。
        <!-- That is, you should never have to use -->
        <!-- the double-colon <code>::</code> construct. -->
        <!-- (e.g. <code>QUAKE::HIDDEN-FUNCTION</code>). -->
	これは二重セミコロン<code>::</code>構造(e.g. <code>QUAKE::HIDDEN-FUNCTION</code>)を使ってはいけないということです。
        <!-- If you need to use double-colons to write real production code, -->
        <!-- something is wrong and needs to be fixed. -->
	もし二重セミコロンを実際のプロダクトで使う必要があったときは、それはどこかが間違っていて、修正を必要としています。
      </p>
      <p>
        <!-- As an exception, -->
        <!-- unit tests may use the internals of the package being tested. -->
	例外として、単体テストはテストのためにパッケージの内部[シンボル]を使っても構いません。
        <!-- So when you refactor, watch out for -->
        <!-- internals used by the package's unit tests. -->
	なのでリファクタリングするときは単体テストで参照されている内部[シンボル]に気を付けましょう。
      </p>
      <p>
        <!-- The <code>::</code> construct is also useful for very temporary hacks, -->
        <!-- and at the REPL. -->
	<code>::</code>構造は本当に一時的なハックやREPLにおいても有用です。
        <!-- But if the symbol really is part of -->
        <!-- the externally-visible definition of the package, -->
        <!-- export it. -->
	しかしそのシンボルが本当に外部から参照できるパッケージの定義ならエクスポートしましょう。 <!--直訳してみましたけど意味が分からないです。-->
      </p>
      <p>
        <!-- You may find that some internal symbols represent concepts -->
        <!-- you usually want to abstract away and hide under the hood, -->
        <!-- yet at times are necessary to expose for various extensions. -->
	内部シンボルには普通は抽象化し、フードの下に隠したいけど様々な拡張のために外部に晒す必要のあるものがあることに気づくでしょう。
        <!-- For the former reason, you do not want to export them, -->
        <!-- yet for the latter reason, you have to export them. -->
	前者の理由のためにはエクスポートしたくはないが、後者の理由のためにはエクスポートする必要がある。
        <!-- The solution is to have two different packages, -->
        <!-- one for your normal users to use, and -->
        <!-- another for the implementation and its extenders to use. -->
	そのような場合には普通の使用と拡張の実装用にパッケージを2つ用意するとよいでしょう。
      </p>
      <p>
        <!-- Each package is one of two types: -->
	それぞれのパッケージには2種類のタイプがあります：
      </p>
      <ul>
        <li>
          <!-- Intended to be included -->
          <!-- in the <code>:use</code> specification of other packages. -->
	  他のパッケージに<code>:use</code>されることを意図したもの。
          <!-- If package <code>A</code> "uses" package <code>B</code>, -->
          <!-- then the external symbols of package <code>B</code> -->
          <!-- can be referenced from within package <code>A</code> -->
          <!-- without a package prefix. -->
	  パッケージ<code>A</code>がパッケージ<code>B</code>を"use"したら
	  <code>B</code>の外部シンボルは<code>A</code>からパッケージプリフィクスなしに参照できます。
          <!-- We mainly use this for low-level modules -->
          <!-- that provide widely-used facilities. -->
	  これは主に広く使われる機能を提供する低レベルモジュールに使われます。
        </li>
        <li>
          <!-- Not intended to be "used". -->
	  "use"されることを意図してないもの。
          <!-- To reference a facility provided by package <code>B</code>, -->
          <!-- code in package <code>A</code> must use an explicit package prefix, -->
          <!-- e.g. <code>B:DO-THIS</code>. -->
	  パッケージ<code>B</code>で提供される機能をパッケージ<code>A</code>で使うには明示的にパッケージプリフィクスを使う必要があります。
	  例: <code>B:DO-THIS</code>.
        </li>
      </ul>
      <p>
        <!-- If you add a new package, it should always be of the second type, -->
        <!-- unless you have a special reason and get permission. -->
	もし新たにパッケージを作るなら、特別な理由と許可がない限り、それは常に[上に挙げた2つのうち]2つめのタイプであるべきです。
        <!-- Usually a package is designed to be one or the other, -->
        <!-- by virtue of the names of the functions. -->
	通常パッケージは関数の名前によって、上の2つのうち、どちらかになるように設計されます。
        <!-- For example, if you have an abstraction called <code>FIFO</code>, -->
        <!-- and it were in a package of the first type -->
        <!-- you'd have functions named things like -->
        <!-- <code>FIFO-ADD-TO</code> and <code>FIFO-CLEAR-ALL</code>. -->
	例えば、<code>FIFO</code>という抽象化した1つめのタイプのパッケージがあったら、<code>FIFO-ADD-TO</code>や<code>FIFO-CLEAR-ALL</code>
	と名付けるでしょう。
        <!-- If you used a package of the second type, -->
        <!-- you'd have names like <code>ADD-TO</code> and <code>CLEAR-ALL</code>, -->
        <!-- because the callers would be saying -->
        <!-- <code>FIFO:ADD-TO</code> and <code>FIFO:CLEAR-ALL</code>. -->
        <!-- (<code>FIFO:FIFO-CLEAR-ALL</code> is redundant and ugly.) -->
	もし2つめのタイプのパッケージなら<code>ADD-TO</code>や<code>CLEAR-ALL</code>といった関数名になるでしょう。なぜなら関数を呼び出すときは
	<code>FIFO:ADD-TO</code>や<code>FIFO:CLEAR-ALL</code>となるからです(<code>FIFO:FIFO-CLEAR-ALL</code>は冗長ですし醜いです)。
      </p>
      <p>
        <!-- Another good thing about packages is that -->
        <!-- your symbol names won't "collide" with the names of other packages, -->
        <!-- except the ones your packages "uses". -->
	パッケージのもう一つ良い点は、自分のシンボルが他の"use"していないパッケージと「衝突」しないことです。
        <!-- So you have to stay away from symbols -->
        <!-- that are part of the Lisp implementation (since you always "use" that) -->
        <!-- and that are part of any other packages you "use", -->
        <!-- but otherwise you are free to make up your own names, -->
        <!-- even short ones, and not worry about some else -->
        <!-- having used the same name. -->
	だから(常に"use"されている)Lisp処理系のシンボルや他の"use"したパッケージのシンボルは使うべきではありませんが、
	その他は短縮名でも衝突を気にすることなく自由に名付けることができます。
        <!-- You're isolated from each other. -->
	他とは完全に独立しているのです。
      </p>
      <p>
        <!-- Your package must not shadow (and thus effectively redefine) -->
        <!-- symbols that are part of the Common Lisp language. -->
	パッケージでCommon Lispの仕様の一部となっているシンボルをシャドウ(そして事実上再定義も)してはいけません。
        <!-- There are certain exceptions, -->
        <!-- but they should be very well-justified and extremely rare: -->
	例外もありますが、これらはかなり正当化されているべきで、ほとんど起こらないはずです:
      </p>
      <ul>
        <li>
          <!-- If you are explicitly replacing a Common Lisp symbol -->
          <!-- by a safer or more featureful version. -->
	  より安全、もしくはより多機能になるように明示的にCommon Lispのシンボルを再定義している場合。
        </li>
        <li>
          <!-- If you are defining a package not meant to be "used", -->
          <!-- and have a good reason to export a symbol -->
          <!-- that clashes with Common Lisp, -->
          <!-- such as <code>log:error</code> and <code>log:warn</code> -->
          <!-- and so on. -->
	  "use"されることを意図していなくて、Common Lispのシンボルと衝突してまでエクスポートするだけの理由があるパッケージを定義する場合。
	  例えば<code>log:error</code>や<code>log:warn</code>など。
        </li>
      </ul>
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<!-- <CATEGORY title="Language usage guidelines"> -->
<CATEGORY title="言語利用法のガイドライン">
  <!-- <STYLEPOINT title="Mostly Functional Style"> -->
  <STYLEPOINT title="極力関数的スタイル">
    <SUMMARY>
      <!-- You should avoid side-effects when they are not necessary. -->
      副作用が必要のない場合はこれを避けるべきです。
    </SUMMARY>
    <BODY>
      <p>
        <!-- Lisp is best used as a "mostly functional" language. -->
        Lispは"極力関数型"言語としての使うのが最適です。
      </p>
      <p>
        <!-- Avoid modifying local variables, try rebinding instead. -->
        変数は変更(代入)するのではなく、再束縛を試みましょう。
      </p>
      <p>
        <!-- Avoid creating objects and the SETFing their slots. -->
        <!-- It's better to set the slots during initialization. -->
        オブジェクトを生成してスロットに値をSETFするのではなく、
        初期化時にスロットに値を設定する方がより好ましいでしょう。
      </p>
      <p>
        <!-- Make classes as immutable as possible, that is, avoid giving slots -->
        <!-- setter functions if at all possible. -->
        極力クラスは変更不可なものとして設計しましょう。換言すれば、それが可能な場合には、スロットにはセッター関数を付加しないということです。
      </p>
      <p>
        <!-- Using a mostly functional style makes it much easier -->
        <!-- to write concurrent code that is thread-safe. -->
        <!-- It also makes it easier to test the code. -->
        極力関数的スタイルに則せば、スレッドセーフな並行動作のコードを書くこともより易くなり、コードをテストするのもまたより易しくなります。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="再帰"><!-- Recursion -->
    <SUMMARY>
      <!-- You should favor iteration over recursion. -->
      あなたは再帰よりも反復を好むべきです。
    </SUMMARY>
    <BODY>
      <p>
        <!-- Common Lisp systems are not required to implement -->
        <!-- function calls from tail positions without leaking stack space -->
        <!-- &#8212; which is known as proper tail calls (PTC), -->
        <!-- tail call elimination (TCE), -->
        <!-- or tail call optimization (TCO). -->
	Common Lispシステムは、真正な末尾呼び出し(PTC)や末尾呼び出しの削除(TCE)、および末尾呼び出し最適化(TCO)などとして知られる、
	スタック空間の溢れることがない末尾位置での関数呼び出しの実装が要求されていません。
        <!-- This means that indefinite recursion through tail calls -->
        <!-- may quickly blow out the stack, -->
        <!-- which hampers functional programming. -->
	これが意味するところは、末尾再帰での無限再帰であったとしてもスタックが即座に溢れてしまうかもしれず、これが関数的なプログラミングの妨げになる、ということです。
        <!-- Still, most serious implementations (including SBCL and CCL) -->
        <!-- do implement proper tail calls, but with restrictions: -->
	とはいうものの、制約付きでもっとも実用的な実装(SBCLやCCL)は最適末尾呼び出しを実装しています:
      </p>
      <ul>
        <li>
          <!-- The <code>(DECLARE (OPTIMIZE ...))</code> settings -->
          <!-- must favor <code>SPEED</code> enough and -->
          <!-- not favor <code>DEBUG</code> too much, -->
          <!-- for some compiler-dependent meanings of "enough" and "too much". -->
	  <code>(DECLARE (OPTIMIZE ...))</code>設定は、
	  いくつかのコンパイラにおける「十分」と「過度」の意味のために、
	  <code>SPEED</code>を十分に優先して、必要以上に<code>DEBUG</code>を優先しないように
	  しなければなりません
          <!-- (For instance, in SBCL, you should avoid <code>(SPEED 0)</code> -->
          <!-- and <code>(DEBUG 3)</code> to achieve proper tail calls.) -->
	  （例えばSBCLにおいて、あなたは末尾呼び出しの優先を結果として得るためには、
	  <code>(SPEED 0)</code>と<code>(DEBUG 3)</code>を回避すべきです）。
        </li>
        <li>
          <!-- There should not be dynamic bindings around the call -->
          <!-- (even though some Scheme compilers are able to properly treat -->
          <!-- such dynamic bindings, called parameters in Scheme parlance). -->
	  関数呼び出しを包むような動的な束縛は避けるべきです。(訳注: 再帰的な関数呼び出しに伴ない、動的束縛が入れ子になると動的束縛も関数呼び出しとは別にスタックを消費するため、これが原因でスタックが溢れる)
          <!-- 動的束縛が再帰呼び出しで入れ子になり、結果としてスタックを溢れさせるのを避けるという意味だと思われますが原文が曖昧で良く分かりません -g000001 -->
	  （いくつかのSchemeコンパイラはこのような、Schemeの用法でパラメタと呼ばれる動的束縛を適切に修正することができますが）
        </li>
      </ul>
      <p>
        <!-- For compatibility with all compilers and optimization settings, -->
        <!-- and to avoid stack overflow when debugging, -->
        <!-- you should prefer iteration or the built in mapping functions -->
        <!-- to relying on proper tail calls. -->
	すべてのコンパイラと最適化設定、そしてデバッグ時のスタックオーバフローを回避するために、
	組み込みの末尾再帰の最適化に依存するよりも、繰り返し構文、もしくはマッピング関数の利用をあなたは優先すべきです。
      </p>
      <p>
        <!-- If you do rely on proper tail calls, -->
        <!-- you must prominently document the fact, -->
        <!-- and take appropriate measures to ensure an appropriate compiler is used -->
        <!-- with appropriate optimization settings. -->
	もしあなたが最適末尾呼び出しに依存することをするのなら、
	あなたは、その動作の実際について明確に文書化し、適切な最適化設定と共に適切なコンパイラを使用することを保証するために
	適切な措置を講じなければなりません。
        <!-- For fully portable code, you may have to use trampolines instead. -->
	完全な移植性をもつコード(訳注: 挙動がコンパイラのセッティングに依らないコード)のためには、あなたは代わりにトランポリンを使わなければならないかもしれません。
      </p>
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="Special variables"> -->
  <STYLEPOINT title="スペシャル変数">
    <SUMMARY>
      スペシャル変数の利用は控え目にしましょう。
    </SUMMARY>
    <BODY>
      <p>
        <!-- Using Lisp "special" (dynamically bound) variables -->
        <!-- as implicit arguments to functions should be used sparingly, -->
        <!-- and only in cases where it won't surprise the person reading the code, -->
        <!-- and where it offers significant benefits. -->
	Lispの「スペシャル」(動的束縛)変数を関数の暗黙の引数として使うことはできるだけ避け、コードを読む人が驚かず、明確な利点がある場合に留めるべきです。
      </p>
      <p>
        <!-- Indeed, each special variable constitutes state. -->
	実際、それぞれのスペシャル変数は状態を持ちます。
        <!-- Developers have to mentally track the state of all relevant variables -->
        <!-- when trying to understand what the code does and how it does it; -->
        <!-- tests have to be written and run with all relevant combinations; -->
        <!-- to isolate some activity, care has to be taken to locally bind -->
        <!-- all relevant variables, including those of indirectly used modules. -->
	開発者はコードの振舞を理解しようとするとき全ての関係する変数の状態を脳内で追う必要がありますし、テストも関連する[変数の]全ての組み合わせを書いて実行する必要がありますし、ある挙動を分離させようとするときもローカル束縛を作るにあたって間接的に使われているモジュールのものも含む全ての関連する[変数を]頭に入れる必要があります。
	<!-- to isolate some activityがコードの振舞なのかコードに対する開発者の振舞なのか判断つきませんでした。上の訳は前者としてます。(κeen) -->
        <!-- They can hide precious information from being printed in a backtrace. -->
	重要な情報がバックトレースで印字されなくなり得ます。
        <!-- Not only is there overhead associated to each new variable, -->
        <!-- but interactions between variables -->
        <!-- can make the code exponentially more complex -->
        <!-- as the number of such variables increases. -->
	そのような変数が増えるにつれ、新たな変数に関連するオーバーヘッドがあるだけでなく、変数同士の相互作用により指数関数的にコードの複雑さが増していきます。
        <!-- The benefits have to match the costs. -->
	利点がコストに見合うようにしなければいけません。
      </p>
      <p>
        <!-- Note though that a Lisp special variable is not a global variable -->
        <!-- in the sense of a global variable in, say, BASIC or C. -->
	しかしLispのスペシャル変数はBASICやCの意味でのグローバス変数ではないことに注意しましょう。
        <!-- As special variables can be dynamically bound to a local value, -->
        <!-- they are much more powerful than -->
        <!-- global value cells where all users necessarily interfere with each other. -->
	スペシャル変数は動的にローカル束縛できるので全てのユーザー同士の干渉のあるグローバル変数より強力です。
      </p>
      <p>
        <!-- Good candidates for such special variables -->
        <!-- are items for which "the current" can be naturally used as prefix, -->
        <!-- such as "the current database connection" or -->
        <!-- "the current business data source". -->
	このようなスペシャル変数の候補として、「現在のデーターベースコネクション」や「現在の業務データソース」のように自然に「現在の」(current)という接尾辞をつけられるものがあります。。
        <!-- They are singletons as far as the rest of the code is concerned, -->
        <!-- and often passing them as an explicit argument -->
        <!-- does not add anything to the readability or maintainability -->
        <!-- of the source code in question. -->
	それ以降のコードに限れば、それらはシングルトンですし、たいていの場合明示的に引数として渡しても問題のコードの可読性やメンテナンス性は向上しません。
      </p>
      <p>
        <!-- They can make it easier to write code that can be refactored. -->
	そのようなスペシャル変数によってコードは書きやすくなりますし、リファクタリングも可能になります。
	<!-- If you have a request processing chain, -->
        <!-- with a number of layers that all operate upon a "current" request, -->
        <!-- passing the request object explicitly to every function -->
        <!-- requires that every function in the chain have a request argument. -->
	リクエストを処理するフローを書いていて、それぞれの処理で「現在の」リクエストを扱うのであれば明示的にリクエストオブジェクトをそれぞれの関数に渡そうと思えば全ての関数がリクエストを引数にとる必要があります。
        <!-- Factoring out code into new functions often requires -->
        <!-- that these functions also have this argument, -->
        <!-- which clutters the code with boilerplate. -->
	コードを書き換えて新しく関数を定義するときもこの引数が必要になり、ボイラープレートで散らかることになります。
      </p>
      <p>
        <!-- You should treat special variables -->
        <!-- as though they are per-thread variables. -->
	スペシャル変数はスレッドローカルな変数であるかのように扱うべきです。
        <!-- By default, you should leave a special variable -->
        <!-- with no top-level binding at all, -->
        <!-- and each thread of control -->
        <!-- that needs the variable should bind it explicitly. -->
	デフォルトでは、スペシャル変数はトップレベルでは束縛せず、必要とするスレッドで明示的に束縛すべきです。
        <!-- This will mean that any incorrect use of the variable -->
        <!-- will result in an "unbound variable" error, and -->
        <!-- each thread will see its own value for the variable. -->
	これによって不適切な変数の使用に対して"unbound variable"エラーが出ますし、各スレッドは各々の値を参照できます。
        <!-- Variables with a default global value should usually be -->
        <!-- locally bound at thread creation time. -->
	グローバルな値を持つ変数は通常スレッドを作るときにローカル束縛されす。
        <!-- You should use suitable infrastructure         -->
        <!-- to automate the appropriate declaration of such variables. -->
	そのような変数を自動的に適切に宣言してくれる適切な基盤が必要です。
      </p>
      
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="Assignment"> -->
  <STYLEPOINT title="代入">
    <SUMMARY>
      <!-- Be consistent in assignment forms. -->
      代入の書法には一貫性を持たせましょう。
    </SUMMARY>
    <BODY>
      <p>
        <!-- There are several styles for dealing with assignment and side-effects; -->
        <!-- whichever a given package is using, -->
        <!-- keep using the same consistently when hacking said package. -->
        <!-- Pick a style that makes sense when starting a new package. -->
        代入と副作用の処方については、(既存のパッケージが採用しているルールを含めて)いくつかのスタイルがありますが、
        何れにせよ既存のパッケージをハックする場合にはパッケージのスタイルとの一貫性を維持しましょう。
        新しくパッケージを作成する場合に道理にかなったスタイルを採択しましょう。
      </p>
      <p>
        <!-- Regarding multiple assignment in a same form, there are two schools: -->
        <!-- the first style groups as many assignments as possible into a single -->
        <!-- <code>SETF</code> or <code>PSETF</code> form -->
        <!-- thus minimizing the number of forms with side-effects; -->
        一つのフォームで、複数の代入を行なうことについては、二つの流儀があります:
        第一の流儀は、複数の代入を可能な限り一つの<code>SETF</code>または、<code>PSETF</code>のフォーム内で行うこととするというものであり、
        従って、副作用を持つフォームの数を最小化するというものです。
        <!-- the second style splits assignments into as many individual -->
        <!-- <code>SETF</code> (or <code>SETQ</code>, see below) forms as possible, -->
        <!-- to maximize the chances of locating forms that modify a kind of place -->
        <!-- by grepping for <code>(setf (foo ...</code>. -->
        第二の流儀は、代入を可能な限り個別の<code>SETF</code> (もしくは、<code>SETQ</code>、下記参照)フォームに分割し、
        grepした時に、<code>(setf (foo ...</code>のような結果となることで、
        代入が行なわれているようなフォームの箇所を特定する機会を最大化するものです。
        <!-- A grep pattern must actually contain as many place-modifying forms -->
        <!-- as you may use in your programs, which may make this rationale either -->
        <!-- convincing or moot depending on the rest of the style of your code. -->
        [このスタイルが]納得できるものか、議論の余地があるものかは、プログラムの残りの箇所がどのようなスタイルかに依るでしょうが、grepの検索結果のパターンは、プログラムで代入が行われている場所の数と実質同じにならなくてはなりません。
        <!-- You should follow the convention used in the package you are hacking.  -->
        <!-- We recommend the first convention for new packages.  -->
        ハックしているパッケージが採用している慣習に従うべきです。
        新規のパッケージの場合は、我々は、最初の慣習をお勧めします。
      </p>
      <p>
        <!-- Regarding <code>SETF</code> and <code>SETQ</code>, -->
        <!-- there are two schools: -->
        <!-- this first regards <code>SETQ</code> -->
        <!-- as an archaic implementation detail, -->
        <!-- and avoids it entirely in favor of <code>SETF</code>; -->
        <!-- the second regards <code>SETF</code> -->
        <!-- as an additional layer of complexity, -->
        <!-- and avoids it in favor of <code>SETQ</code> whenever possible -->
        <!-- (i.e. whenever the assigned place is a variable or symbol-macro). -->
        <!-- You should follow the convention used in the package you are hacking. -->
        <!-- We recommend the first convention for new packages. -->
        
        <code>SETF</code> と <code>SETQ</code> の使い分けに関しては、二つの流儀があります:
        第一の流儀は、<code>SETF</code>の利用を支持し、<code>SETQ</code>は、古式ゆかしいLISPのあれこれと捉え、これを一切排除します。
        第二の流儀は、<code>SETF</code>を、<code>SETQ</code>に複雑さを付け加えたものであると解釈し、<code>SETQ</code>が使えるところには<code>SETF</code>は使わないことを支持します。
        (つまり、書式上、変数として代入可能な場合には、変数とシンボルマクロを問わずに)。
        既存のパッケージをハックしている場合には、その流儀に沿うべきです。
        我々としては、新たなパッケージには、第一の流儀を推奨します。
      </p>
      <p>
        <!-- In the spirit of a mostly pure functional style, -->
        <!-- which makes testing and maintenance easier, -->
        <!-- we invite you to consider how to do things with the fewest assignments required. -->
        テストと保守が容易になるという、極力純粋関数型スタイルの精神に則り、どうすれば代入の必要性が最小限になるかを考慮することをお勧めします。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="アサーションとコンディション"><!-- Assertions and Conditions -->
    <SUMMARY>
      <!-- You must make proper usage of assertions and conditions. -->
      あなたはアサーションとコンディションを適切に使わなければなりません。
    </SUMMARY>
    <BODY>
      <ul>
        <li>
          <!-- <code>ASSERT</code> should be used ONLY to detect internal bugs. -->
	  <code>ASSERT</code>は内部的のバグの検出のため「だけ」に使われなければなりません。
          <!-- Code should <code>ASSERT</code> invariants whose failure indicates -->
          <!-- that the software is itself broken. -->
	  コードはソフトウェア自身が破壊される可能性のある、不変性の破壊を指摘するために、
	  <code>ASSERT</code>を使うべきです。<!-- こんなに意訳しちゃっていいのかな：とよずみ -->
          <!-- Incorrect input should be handled properly at runtime, -->
          <!-- and must not cause an assertion violation. -->
	  実行時のまちがった入力は適切に始末されるべきであり，
	  アサーション違反を発生させてはなりません。
          <!-- The audience for an <code>ASSERT</code> failure is a developer. -->
	  <code>ASSERT</code>の失敗は開発者に向けられるものです。
          <!-- Do not use the data-form and argument-form in <code>ASSERT</code> -->
          <!-- to specify a condition to signal. -->
	  <code>ASSERT</code>のなかで状態を知らせるためにデータ形式や引数の形式を
	  使ってはなりません。
          <!-- It's fine to use them to print out a message for debugging purposes -->
          <!-- (and since it's only for debugging, there's no issue of -->
          <!-- internationalization). -->
	  これはデバッグの目的のために、メッセージを出力するために使います
	  （またこれはデバッグの用途に供する場合のみのためのものであり、
	  国際化に対応していません）。
        </li>
        <li>
          <!-- <code>CHECK-TYPE</code>, -->
          <!-- <code>ETYPECASE</code> are also forms of assertion. -->
          <code>CHECK-TYPE</code>と
          <code>ETYPECASE</code>はアサーションと同様のフォームです。
          <!-- When one of these fails, that's a detected bug. -->
	  これらのうちどちらかが失敗する場合は、パグが検出されたということです。
          <!-- You should prefer to use <code>CHECK-TYPE</code> -->
          <!-- over (DECLARE (TYPE ...)) -->
          <!-- for the inputs of functions. -->
	  あなたは、関数の入力に対しては<code>(DECLARE (TYPE ...))</code>より
	  <code>CHECK-TYPE</code>を使うようにするべきです。
        </li>
        <li>
          <!-- Your code should use assertions and type checks liberally. -->
	  あなたのコードはアサーションと型チェックを十分に使用するべきです。
          <!-- The sooner a bug is discovered, the better! -->
	  早期のバグ発見は良いことです!
          <!-- Only code in the critical path for performance -->
          <!-- and internal helpers should eschew -->
          <!-- explicit assertions and type checks. -->
	  明示的なアサーションや型チェックを省くのは、
	  パフォーマンスのクリティカル・パス上にあるコード、もしくは内部のヘルパにおいてのみであるべきです。
        </li>
        <li>
          <!-- Invalid input, such as files that are read -->
          <!-- but do not conform to the expected format, -->
          <!-- should not be treated as assertion violations. -->
	  ファイルのようなものの入力で、読むことはできるが、予想している形式にそぐわぬ妥当でない入力を、アサーション違反で取り扱うべきではありません。
          <!-- Always check to make sure that input is valid, -->
          <!-- and take appropriate action if it is not, -->
          <!-- such as signalling a real error. -->
	  常に入力が妥当であるかを確認し、
	  そうでない場合は、真のエラーを通知するといった適切な対応をとってください。
        </li>
        <li>
          <!-- <code>ERROR</code> should be used -->
          <!-- to detect problems with user data, requests, permissions, etc., -->
          <!-- or to report "unusual outcomes" to the caller. -->
	  <code>ERROR</code>は
	  ユーザデータ、要求、権限等についての問題検出等々や、
	  呼び出し元へと異常な結果が出たことを知らせるために使うべきです。
        </li>
        <li>
          <!-- <code>ERROR</code> should always be called -->
          <!-- with an explicit condition type; -->
	  <code>ERROR</code>は常に明示的なコンディションタイプの指定と共に
	  呼ばれるべきです。
          <!-- it should never simply be called with a string. -->
	  これを文字列(訳注: エラーメッセージ)のみの簡単な形式で呼び出すべきではありません。
          <!-- This enables internationalization. -->
	  この明示的なコンディションの指定は国際化を可能にします。(訳注: 具体的にはどう実現するのだろう。コンディションと言語をmixinしたりするのだろうか -g000001)
        </li>
        <li>
          <!-- Functions that report unusual outcomes -->
          <!-- by signaling a condition should say so explicitly in their contracts -->
          <!-- (their textual descriptions, in documentation and docstrings etc.). -->
	  関数がコンディションの通知によって異常な結果を知らせることについて、
	  （テキスト形式の説明、マニュアルあるいは文書化用文字列を用いて）
	  そのコンディションの後始末を請け負う者<!-- contractsってこういう意味ですよね？：とよずみ -->
	  に明確に知らせるべきです。
          <!-- When a function signals a condition -->
          <!-- that is not specified by its contract, that's a bug. -->
	  関数がコンディションを通知したとき、そのコンディションの後始末について規約として
	  規定されていないのなら、それはバグです。
          <!-- The contract should specify the condition class(es) clearly. -->
	  コンディションの規約はコンディションクラスについて明確に規定すべきです。<!-- コンディションの規約ってなんだよというところですが、規約と書いても分からないので… -g000001) -->
          <!-- The function may then signal any condition -->
          <!-- that is a type-of any of those conditions. -->
	  関数は、それらコンディションのうちのいずれかの型の、
	  何らかのコンディションを通知してかまいません。
          <!-- That is, signaling instances of subclasses -->
          <!-- of the documented condition classes is fine. --> <!-- 原文の意味が良く分からないです… -g000001 -->
	  つまり、明快に文書化されたコンディションクラスのサブクラスのインスタンスからの通知は好ましいということです。
        </li>
        <li>
          <!-- Complex bug-checks may need to use <code>ERROR</code> -->
          <!-- instead of <code>ASSERT</code>. -->
          複雑なバグチェックには<code>ASSERT</code>ではなく、
	  <code>ERROR</code>を使う必要があるかもしれません。
        </li>
        <li>
          <!-- When writing a server, you must not call <code>WARN</code>. -->
          サーバを書いているときに、あなたは<code>WARN</code>を呼んではなりません。
          <!-- Instead, you should use the appropriate logging framework. -->
	  そうではなく、あなたは、適切なロギングフレームワークを使うべきです。
        </li>
        <li>
          <!-- Code must not call <code>SIGNAL</code>. -->
	  コードは、<code>SIGNAL</code>を呼んではなりません。
          <!-- Instead, use <code>ERROR</code> or <code>ASSERT</code>. -->
	  そうではなく、<code>ERROR</code>あるいは<code>ASSERT</code>を使うべきです。
        </li>
        <li>
          <!-- Code should not use <code>THROW</code> and <code>CATCH</code>; -->
	  コードは、<code>THROW</code>と<code>CATCH</code>を使ってはなりません。
          <!-- instead use the <code>restart</code> facility. -->
	  そうではなく、<code>restart</code>(訳注:再起動)機能を使うべきです。
        </li>
        <li>
          <!-- Code should not generically handle all conditions, -->
          <!-- e.g. type <code>T</code>, or use <code>IGNORE-ERRORS</code>. -->
	  コードは、すべてのコンディションをまとめて始末すべきではありません。
	  例: (訳注: コンディションタイプとして)<code>T</code>クラスの指定や、<code>IGNORE-ERRORS</code>の使用
          <!-- Instead, let unknown conditions propagate to -->
          <!-- the standard ultimate handler for processing. -->
	  そうではなく、未知のコンディションについては、
	  標準で定めた最上位のハンドラに処理させるために伝搬させます。<!-- the standard が何を指してるのか分からないですね。ANSI標準なのか社内の規約なのか -g000001 -->
        </li>
        <li>
          <!-- There are a few places where handling all conditions is appropriate, -->
          <!-- but they are rare. -->
	  数少ない箇所においては、すべてのコンディションをまとめて(訳注:捕捉して)<!-- って書かないと意味が
	  通らないだろうという判断で、以後全部書いています。：とよずみ -->始末することが、
	  適していることがありますが、こういった場合は稀です。
          <!-- The problem is that handling all conditions can mask program bugs. -->
	  問題は、すべてのコンディションをまとめて始末することが、プログラムのバグの隠蔽を可能にすることです。
          <!-- If you <em>do</em> need to handle "all conditions", -->
          <!-- you MUST handle only <code>ERROR</code>, <em>not</em> <code>T</code> -->
          <!-- and not <code>SERIOUS-CONDITION</code>. -->
	  もしあなたがすべてのコンディションをまとめて始末するの<em>のなら</em>
	  あなたは、<code>ERROR</code>のみをその対象にしなければならず、<code>T</code>
          や<code>SERIOUS-CONDITION</code>を<em>その対象に含めてはなりません</em>。
          <!-- (This is notably because CCL's process shutdown -->
          <!-- depends on being able to signal <code>process-reset</code> -->
          <!-- and have it handled by CCL's handler, -->
          <!-- so we must not interpose our own handler.) -->
	  （CCLではブロセスの終了を、<code>process-reset</code>の
	  通知とそれをCCLのハンドラで始末することに依存しているため、
	  とりわけ問題となります。）
        </li>
        <li>
          <!-- <code>(error (make-condition 'foo-error ...))</code> -->
          <!-- is equivalent to <code>(error 'foo-error ...)</code> — -->
          <!-- code must use the shorter form. -->
          <code>(error (make-condition 'foo-error ...))</code>
          は、<code>(error 'foo-error ...)</code> &#8212;
	  と同等ですが、コードはより短い形式を使わなければなりません。
        </li>
        <li>
          <!-- Code should not signal conditions from inside the cleanup form of -->
          <!-- <code>UNWIND-PROTECT</code> -->
          <!-- (unless they are always handled inside the cleanup form), -->
          <!-- or otherwise do non-local exits from cleanup handers -->
          <!-- outside of the handler e.g. <code>INVOKE-RESTART</code>. -->
          コードは、<code>UNWIND-PROTECT</code>のクリーンアップ節内でコンディションを通知するべきではありません。
          （常にクリーンアップ節内でコンディションを扱っているのでもない限り）
          あるいはまた別に、クリーンアップの処理部からその外に向けての非局所脱出もすべきでありません。例:<code>INVOKE-RESTART</code>.
        </li>
        <li>
          <!-- Do not clean up by resignaling. -->
	  再通知によって処理の後始末をしてはなりません。
          <!-- If you do that, and the condition is not handled, -->
          <!-- the stack trace will halt at the point of the resignal, -->
          <!-- hiding the rest. -->
	  もしそうした場合、コンディションが始末されないと、
	  スタックトレースは、再通知された地点で停止し、
	  残りを隠してしまいます。
          And the rest is the part we really care about!
          <BAD_CODE_SNIPPET>
            ;; 悪い例
            (handler-case
              (catch 'ticket-at
                (etd-process-blocks))
              (error (c)
                (reset-parser-values)
                  (error c)))
          </BAD_CODE_SNIPPET>
          <CODE_SNIPPET>
            ;; 良い例
            (unwind-protect
              (catch 'ticket-at
                (etd-process-blocks))
              (reset-parser-values))
          </CODE_SNIPPET>
        </li>
      </ul>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="型の判定"><!-- Type Checking -->
    <SUMMARY>
      <!-- If you know the type of something, you should make it explicit -->
      <!-- in order to enable compile-time and run-time sanity-checking. -->
      もし、なんらかの要素について、その型が何であるかあなたが知っているのなら、
      コンパイル時そして実行時の正常性を確かめるために、あなたはそれを明示すべきです。
    </SUMMARY>
    <BODY>
      
      <p>
        <!-- If your function is using a special variable as an implicit argument, -->
        <!-- it's good to put in a <code>CHECK-TYPE</code> for the special variable, -->
        <!-- for two reasons: -->
        <!-- to clue in the person reading the code -->
        <!-- that this variable is being used implicitly as an argument, -->
        <!-- and also to help detect bugs. -->
	もしあなたの関数がスペシャル変数を暗黙の引数として使うときは、 
	他人がコードを読むときに、その変数が暗黙の引数として扱われていること理解し、バグを検出するための手がかりとなるよう、
	そのスペシャル変数を<code>CHECK-TYPE</code>の中におきます。
      </p>
      
      <p>
        <!-- Using <code>(declare (type ...))</code> -->
        <!-- is the least-desirable mechanism to use -->
        <!-- because, as Scott McKay puts it: -->
	<code>(declare (type ...))</code>の使用は、
	最低限にすることが望ましいです。その理由については、
	Scott McKayによって説明されています。
      </p>
      <blockquote>
        <p>
          <!-- The fact is, <code>(declare (type ...))</code> does different things -->
          <!-- depending on the compiler settings of speed, safety, etc. -->
	  実際のところ、<code>(declare (type ...))</code>は
	  コンパイラ設定のspeedや、safetyの設定に依存している。

          <!-- In some compilers, when speed is greater than safety, -->
          <!-- <code>(declare (type ...))</code> will tell the compiler -->
          <!-- "please assume that these variables have these types" -->
          <!-- <em>without</em> generating any type-checks. -->
	  いくつかのコンパイラはsafetyよりspeedを優先した場合、
	  <code>(declare (type ...))</code>
	  を、コンパイラに対する
	  「これらの変数はこれらの型だと信用してください」
	  というメッセージとし、いくつかの型判定を<em>しない</em>ために使います。

          <!-- That is, if some variable has the value <code>1432</code> in it, -->
          <!-- and you declare it to be of type <code>string</code>, -->
          <!-- the compiler might just go ahead and use it as though it's a string. -->
	  例えば、ある変数が値<code>1432</code>を持ち、
	  あなたがその型を<code>string</code>として宣言すると、
	  コンパイラはそれを文字列と見做して使用します。
        </p>
        <p>
          <!-- Moral: don't use <code>(declare (type ...))</code> -->
          <!-- to declare the contract of any API functions, -->
          <!-- it's not the right thing. -->
	  良識：<code>(declare (type ...))</code>を、
	  なんらかのAPI関数の契約として使ってはいけません。
	  それはうまいやり方ではありません。
          <!-- Sure, use it for "helper" functions, but not API functions. -->
	  もちろん、ヘルパー関数のためには使えますが、API関数のために使ってはいけません。
        </p>
      </blockquote>
      <p>
        <!-- You should, of course, use appropriate declarations -->
        <!-- in internal low-level functions -->
        <!-- where these declarations are used for optimization. -->
	もちろん、これらの宣言は、内部の低レベル関数の中で最適化のために使用すべきです。
        <!-- When you do, however, see our recommendations for -->
        <!-- <a href="#Unsafe_Operations">Unsafe Operations</a>. -->
	そのようにするときは、我々の
	<a href="#Unsafe_Operations">安全でない操作</a>
	の節も読んでください。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="CLOS">
    <SUMMARY>
      <!-- Use CLOS appropriately. -->
      CLOS は適切に使いましょう。
    </SUMMARY>
    <BODY>
      <p>
        <!-- When a generic function is intended to be called from other -->
        <!-- modules (other parts of the code), there should be an -->
        <!-- explicit <code>DEFGENERIC</code> form, -->
        <!-- with a <code>:DOCUMENTATION</code> string -->
        <!-- explaining the generic contract of the function -->
        <!-- (as opposed to its behavior for some specific class). -->
        <!-- It's generally good to do explicit <code>DEFGENERIC</code> forms, -->
        <!-- but for module entry points it is mandatory. -->
        総称関数が、他のモジュール(コードの他の部分)から呼び出されることになっている場合、
        その関数の(ある特定のクラスの振る舞いに対するという意味で)包括的な規約を説明するドキュメンテーションストリングの付けられた<code>DEFGENERIC</code>フォームを明示的に書くべきです。
        一般に、<code>DEFGENERIC</code>フォームを明示的に書くのは良いことですが、 モジュールのエントリポイントに対しては必須です。
      </p>
      <p>
        <!-- When the argument list of a generic function includes -->
        <!-- <code>&amp;KEY</code>, -->
        <!-- the <code>DEFGENERIC</code> should always explicitly list -->
        <!-- all of the keyword arguments that are acceptable, -->
        <!-- and explain what they mean. -->
        <!-- (Common Lisp does not require this, but it is good form, -->
        <!-- and it may avoid spurious warnings on SBCL.) -->
        総称関数の引数リストが<code>&amp;KEY</code>を含む場合、その<code>DEFGENERIC</code>には、受付可能な全てのキーワード引数を常に明示的に記載すべきです。
        また、それぞれについて[docstringで]説明があるべきです。
        (Common Lispは、このことを要求していませんが、これは理に叶ったことですし、SBCLでは不要な警告を避けることができます。)
      </p>
      <p>
        <!-- You should avoid <code>SLOT-VALUE</code> and <code>WITH-SLOTS</code>, -->
        <!-- unless you absolutely intend to circumvent -->
        <!-- any sort of method combination that might be in effect for the slot. -->
        <!-- Rare exceptions include <code>INITIALIZE-INSTANCE</code> -->
        <!-- and <code>PRINT-OBJECT</code> methods and -->
        <!-- accessing normally hidden slots in the low-level implementation of -->
        <!-- methods that provide user-visible abstractions. -->
        <!-- Otherwise, you should use accessors, -->
        <!-- <code>WITH-ACCESSORS</code> -->
        スロットに影響を及ぼす一切のメソッドコンビネーションを回避するという、はっきりとした意図があるのでなければ、
        <code>SLOT-VALUE</code>や<code>WITH-SLOTS</code>の利用は避けるべきです。
        数少ない例外には、<code>INITIALIZE-INSTANCE</code>メソッドと<code>PRINT-OBJECT</code>メソッド、
        そして、通常はユーザーに見える抽象化を提供するメソッドの低レベルの実装に隠蔽されているスロットへのアクセスが含まれます。
        これらの例外のどれにも当てはまらない場合は、アクセッサと<code>WITH-ACCESSORS</code>を使うべきです。
      </p>
      <p>
        <!-- Accessor names generally follow a convention of -->
        <!-- <code>&lt;protocol-name&gt;-&lt;slot-name&gt;</code>, -->
        <!-- where a "protocol" in this case loosely indicates -->
        <!-- a set of functions with well-defined behavior. -->
        一般にアクセサの命名は<code>&lt;protocol-name&gt;-&lt;slot-name&gt;</code>という慣習に従います。
        ここで"プロトコル"とは、明確に定義された振る舞いを持つ一連の関数[機能?]を大まかに示しています。
      </p>
      <p>
        <!-- No implication of a formal "protocol" concept is necessarily intended, -->
        <!-- much less first-class "protocol" objects. -->
	<!-- 直訳: きちんとした"プロトコル"の概念を前提とする・含意する(imply)こと(implication) +
	     そういったことは必ずしも意図してはいない (no such thing is necessarily intended) = べつに意図していない -->
	"プロトコル"については、ここではべつにそのきちんとした定義について考えているわけではありません。
	ましてや、ファーストクラスの"プロトコル"オブジェクトがあるわけでもありません。

        <!-- However, there may indeed be an abstract CLOS class -->
        <!-- or an -->
        <!-- <a href="http://common-lisp.net/~frideau/lil-ilc2012/lil-ilc2012.html">Interface-Passing Style</a> interface -->
        <!-- that embodies the protocol. -->
        <!-- Further (sub)classes or (sub)interfaces may then implement -->
        <!-- all or part of a protocol by defining -->
        <!-- some methods for (generic) functions in the protocol, -->
        <!-- including readers and writers. -->
        しかしながら、実際にそのプロトコルを具体的に表現する抽象的なCLOSクラスや
        <a href="http://common-lisp.net/~frideau/lil-ilc2012/lil-ilc2012.html">Interface-Passing Style</a>
        のインターフェイスはありえます。
        そういうときに、さらなる(下位の)クラスや(下位の)インターフェイスが、リーダやライター等の、
        プロトコルに含まれる(総称)関数のためのメソッドを定義することで、プロトコルの一部または全部を実装することができます。
      </p>
      <p>
        <!-- For example, if there were a notional protocol called -->
        <!-- is <code>pnr</code> with accessors <code>pnr-segments</code> -->
        <!-- and <code>pnr-passengers</code>, then -->
        <!-- the classes <code>air-pnr</code>, <code>hotel-pnr</code> and -->
        <!-- <code>car-pnr</code> could each reasonably implement -->
        <!-- methods for <code>pnr-segments</code> and <code>pnr-passengers</code> -->
        <!-- as accessors. -->
        例を挙げると、<code>pnr</code>と呼ばれる抽象的なプロトコルがあったとして、
        それは、<code>pnr-segments</code>と、<code>pnr-passengers</code>いうアクセサを持つとします。
        そのとき、<code>air-pnr</code>、<code>hotel-pnr</code>、<code>car-pnr</code>というクラスが、
        <code>pnr-segments</code>や、<code>pnr-passengers</code>のメソッドがアクセサとして実装できることは理に叶っているというものです。
      </p>
      <p>
        <!-- By default, an abstract base class name is used -->
        <!-- as the notional protocol name, so accessor names default -->
        <!-- to <code>&lt;class-name&gt;-&lt;slot-name&gt;</code>; -->
        <!-- while such names are thus quite prevalent, -->
        <!-- this form is neither required nor even preferred. -->
        <!-- In general, it contributes to "symbol bloat", -->
        <!-- and in many cases has led to a proliferation of "trampoline" methods. -->
        デフォルトでは、抽象基底クラスの名前は、抽象的なプロトコルの名前として使われるので、
        アクセサの名前は<code>&lt;class-name&gt;-&lt;slot-name&gt;</code>と名付けられます。
        このような名前は広く行き渡ってはいますが、この形式は、必須のものでも、望ましいものでもありません。
        総じてこれは、"シンボルが膨れ上がる(symbol bloat)"を助長するものであり、また、多くの場合、"トランポリン"メソッドの蔓延に繋がります。
      </p>
      <p>
        <!-- Accessors named <code>&lt;slot-name&gt;-of</code> should not be used. -->
        <code>&lt;slot-name&gt;-of</code>という名前を持つアクセサは使用すべきではありません。 
      </p>
      <p>
        <!-- Explicit <code>DEFGENERIC</code> forms should be used when there are -->
        <!-- (or it is anticipated that there will be) -->
        <!-- more than one <code>DEFMETHOD</code> for that generic function. -->
        <!-- The reason is that the documentation for the generic function -->
        <!-- explains the abstract contract for the function, -->
        <!-- as opposed to explaining what an individual method does for -->
        <!-- some specific class(es). -->
        総称関数の定義に一つより多くの<code>DEFMETHOD</code>が使われる(ことになると思われる)場合、
        <code>DEFGENERIC</code>フォームを明示的に使用すべきです。
        理由は、ある特定的なクラスの個々のメソッドが説明するものに対する意味で、総称関数のドキュメンテーションは、
        その関数の抽象的な規約を説明するものだからです。
      </p>
      <p>
        <!-- You must not use generic functions where there is no notional protocol. -->
        <!-- To put it more concretely, -->
        <!-- if you have more than one generic function that specializes its Nth argument, -->
        <!-- the specializing classes should all be descendants of a single class. -->
        <!-- Generic functions must not be used for "overloading", -->
        <!-- i.e. simply to use the same name for two entirely unrelated types. -->
        抽象的なプロトコルが無い場合に総称関数を使ってはいけません。
        より具体的に述べるならば、もし、N番目の引数を特定化している複数の総称関数のメソッド
        [訳注: 原文はgeneric functionの後ろにMETHODがあるべきと考えます]
        があるとすれば、特定化を行なっているのクラスは、すべてある一つのクラスの子孫であるべきです。
        総称関数は、"オーバーロード"のために使ってはいけません。
        (言い換えれば、全く関連の無い型の総称関数に対して単純に同じ名前を使ってはいけません。)
        <!-- g1: ***TODO 意図が掴めない… -->
	<!-- guicho2.71828 : 議論の余地あり、とりあえず書いておきます。
	[ 訳注解説 : あなたがゲームのプログラマだと考えてみてください。あなたはユーティリティ関数としてDLISTクラス(doubly linked list)
	と、ゲームのキャラクター(PERSON)クラスの両方を実装します。DLISTは双方向のポインタを持つので、まずあなたはこのアクセッサ関数を
	TO,FROMと名づけました。PERSONの実装に入った時、あなたはそのAIが行き先の座標ベクトルと一つ前の行き先のベクトルを覚えている
	必要があることに気づきました。あなたはそれらに再びTOとFROMと名付けようとし、それらが既に使われていることを思い出しました…
	そして思う、「総称関数を使えば良い！」 これが悪い場合の例です。そうではなく、例えば
	metabang.cl-containersでそうされているように、DLISTにはprevious-elementなどを、PERSONにはdestinationなどの名前をつけるべきです。
	もしあくまでtoとfromという名前に固執したいのならば、上で挙げたプロトコルのアクセサの命名規則に従って、
	たとえばプロトコル[container]とプロトコル[agent]を念頭におき（もしIPSが成功すればそれを定義する構文があるはずです）、
	メソッドの名前はCONTAINER-TO,AGENT-TOというようにすべきです。AGENTは実際に親クラスを作って、PERSONクラスや他にも
	MONSTER,SHIP,HORSEなどのサブクラスを作り、プロトコル内のメソッドで実装するのがいいでしょう。] たぶんこういうことです。
	-->
      </p>
      <p>
        <!-- More precisely, it's not really -->
        <!-- whether they descend from a common superclass, -->
        <!-- but whether they obey the same "protocol". -->
        <!-- That is, the two classes should handle the same set of generic functions, -->
        <!-- as if there were an explicit <code>DEFGENERIC</code> for each method. -->
        より正確には、それらが実際、共通のスーパークラスの子孫なのかどうかではなく、同じ"プロトコル"に従うかどうか、ということです。
        つまり、個々のメソッドに明確な<code>DEFGENERIC</code>があるかのように、二つのクラスは同じ総称関数のセットを扱っているべきなのです。
      </p>
      <p>
        <!-- Here's another way to put it. -->
        <!-- Suppose you have two classes, A and B, and a generic function F. -->
        <!-- There are two methods for F, -->
        <!-- which dispatch on an argument being of types A and B. -->
        <!-- Is it plausible that there might be a function call somewhere -->
        <!-- in the program that calls F, -->
        <!-- in which the argument might sometimes, at runtime, -->
        <!-- be of class A and other times be of class B? -->
        <!-- If not, you probably are overloading and -->
        <!-- should not be using a single generic function. -->
        別の方法で説明しましょう。
        AとBの二つのクラスと、総称関数Fがあり、Fにはメソッドが二つあり、これらは、渡されたAとBの型の引数でディスパッチするものとします。
        プログラム中にある一つのFの関数呼び出しについて、実行時にその引数がAのクラスとなる場合とBのクラスとなる場合があると思われるかどうか。
        もし、思われないのであれば、おそらくオーバーロードしており、一つの総称関数を使用すべきではありません。
        別の方法で説明すると、AとBの二つのクラスと、総称関数Fがあるとした場合、
	Fにはメソッドが二つあり、これらは、渡されたAとBの型の引数でディスパッチします。
        プログラム中のどこかのFの関数呼び出し中で、引数が実行時にAのクラスとなるものと、
	別の時にはBのクラスとなるようなものでの挙動が妥当なものかどうか。
        そうでなければ、恐らくオーバーロードしており、単一の総称関数を使用するべきではありません。
	<!-- guicho2.71828 上記の例では、DLISTの来る場所にいきなりPERSONがくる可能性はありません。
	     そういう時に同じ名前を使うのはどうよという話 -->
      </p>
      <p>
        <!-- We allow one exception to this rule: -->
        <!-- it's OK to do overloading -->
        <!-- if the corresponding argument "means" the same thing. -->
        <!-- Typically one overloading allows an X object, -->
        <!-- and the other allows the name of an X object, -->
        <!-- which might be a symbol or something. -->
        このルールには一つの例外が認められます:
        対応する引数が同じものを"意味"する場合、オーバーロードしても良し、とします。
        典型的には、一つのオーバーロードではXオブジェクトを認め、他のオーバーロードではXオブジェクトの名前(シンボルかなにかになるでしょう)を認めるというものです。
	<!-- guicho2.71828 make-instance は典型的なやつだと思います。引数はクラス自身でもいいしクラス名のシンボルでもいい。 -->
      </p>
      <p>
        <!-- You must not use MOP "intercessory" operations at runtime. -->
        <!-- You should not use MOP "intercessory" operations at compile-time. -->
        <!-- At runtime, they are at worst a danger, at best a performance issue. -->
        <!-- At compile-time, it is usually cleaner that -->
        <!-- macros should set things up the right way in one pass -->
        <!-- than have to require a second pass of fixups through intercession; -->
        <!-- but sometimes, fixups are necessary to resolve forward references, -->
        <!-- and intercession is allowed then. -->
        <!-- MOP intercession is a great tool for interactive development, -->
        <!-- and you may enjoy it while developping and debugging; -->
        <!-- but you should not use it in normal applications. -->
        MOPのintercessory(仲裁的)オペレーション[訳注:intercessionは技術用語で、
        プログラムの構成要素を調べる(introspection)ことに対して、その構成要素を変更することを指します
        (出典: <a href="http://bc.tech.coop/blog/050919.html">http://bc.tech.coop/blog/050919.html</a>)。
        このようなオペレータの例としては、<code>defclass</code>の内部で使われる<code>COMPUTE-CLASS-PRECEDENCE-LIST</code>
        や<code>DEFMETHOD</code>の内部で使われる<code>ADD-METHOD</code>等があります。]を実行時に使用してはなりません。
        MOPの"intercessory"オペレーターをコンパイル時に使用してもなりません。
        実行時では、最悪の場合、危険を犯すことになり、良くてもパフォーマンス上の問題があります。
        コンパイル時では、通常、しかるべきマクロで事を正しく1パスで行う方が、2パス目が必要となるintercessionによる対処より簡潔です。
        しかし、前方参照の解決のための対処が必要なこともあるでしょう。そのときにはintercessionの利用も許されま
        MOPのintercessionは、対話的開発では素晴らしい道具ですし、開発中とデバッグ中は、楽しんで使うことができるでしょうが、
        通常のアプリケーション内でこれを利用するべきではありません。
	<!-- MOPのintercession/introspectionについては http://bc.tech.coop/blog/050919.html 
	     簡単に言うとintrospectionは classのメタ情報の読み出し
	     intercessionは class への書き込み・変更
	     ［ラテン語「…の間へ行く」の意 (INTER-+cēdere ‘go'); 【名詞】 intercession］ by weblio
	-->
      </p>
      <p>
        <!-- If a class definition creates a method -->
        <!-- as a <code>:READER</code>, <code>:WRITER</code>, -->
        <!-- or <code>:ACCESSOR</code>, -->
        <!-- do not redefine that method. -->
        <!-- It's OK to add <code>:BEFORE</code>, <code>:AFTER</code>, -->
        <!-- and <code>:AROUND</code> methods, -->
        <!-- but don't override the primary method. -->
        クラス定義で<code>:READER</code>、<code>:WRITER</code>や<code>:ACCESSOR</code>メソッドがつくられる場合、
	これらのメソッドを再定義してはいけません。
        <code>:BEFORE</code>、<code>:AFTER</code>や、<code>:AROUND</code>メソッドを追加することはOKですが、
        プライマリメソッドをオーバーライドしてはいけません。
      </p>
      <p>
        <!-- In methods with keyword arguments, -->
        <!-- you must always use <code>&amp;KEY</code>, -->
        <!-- even if the method does not care about the values of any keys, -->
        <!-- and you should never use <code>&amp;ALLOW-OTHER-KEYS</code>. -->
        <!-- As long as a keyword is accepted by any method of a generic function, -->
        <!-- it's OK to use it in the generic function, -->
        <!-- even if the other methods of the same generic function -->
        <!-- don't mention it explicitly. -->
        <!-- This is particularly important -->
        <!-- for <code>INITIALIZE-INSTANCE</code> methods, -->
        <!-- since if you did use <code>&amp;ALLOW-OTHER-KEYS</code>, -->
        <!-- it would disable error checking for misspelled or wrong keywords -->
        <!-- in <code>MAKE-INSTANCE</code> calls! -->
        キーワード引数を持つメソッドでは、常に<code>&amp;KEY</code>を使わなければなりません。
        たとえ、メソッドがどのキーワード引数の値にも関知しない場合であっても、<code>&amp;ALLOW-OTHER-KEYS</code>は使うべきではありません。
        あるキーワードが総称関数のいずれかのメソッドで受け付けられる限り、総称関数でそのキーワードを使うことができます。
        同じ総称関数の他の全てのメソッドが明示的に触れなくてもです。[訳注: CLHS 3.5.1.4のことですね<!-- @nfunato -->]
        このことは、特に<code>INITIALIZE-INSTANCE</code>メソッドで重要です。
        ひとたび<code>&amp;ALLOW-OTHER-KEYS</code>を使ったならば、ミススペルであろうと、間違ったキーワードであろうと、
        <code>MAKE-INSTANCE</code>の呼び出しでのエラーチェックを無効にしてしまうからです!
      </p>
      
      <p>
        <!-- A typical <code>PRINT-OBJECT</code> method might look like this: -->
        典型的な<code>PRINT-OBJECT</code>メソッドは、下記の様になるでしょう:
      </p>
      <CODE_SNIPPET>
        (defmethod print-object ((p person) stream)
          (print-unprintable-object (p stream :type t :identity t)
            (with-slots (first-name last-name) p
              (safe-format stream "~a ~a" first-name last-name))))
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>
</CATEGORY>
<!-- <CATEGORY title="Meta-language guidelines"> -->
<CATEGORY title="メタ言語ガイドライン">
  <!-- <STYLEPOINT title="Macros"> -->
  <STYLEPOINT title="マクロ">
    <SUMMARY>
      <!-- Use macros when appropriate, which is often. -->
      <!-- Define macros when appropriate, which is seldom. -->
      マクロを使うことは多いですが、適切な場合に利用しましょう。
      それほど多くありませんが、それが適切な場合にはマクロを定義しましょう。
    </SUMMARY>
    <BODY>
      <p>
        <!-- Macros bring syntactic abstraction, which is a wonderful thing. -->
        <!-- It helps make your code clearer, by describing your intent -->
        <!-- without getting bogged in implementation details -->
        <!-- (indeed abstracting those details away). -->
        <!-- It helps make your code more concise and more readable, -->
        <!-- by eliminating both redundancy and irrelevant details. -->
        <!-- But it comes at a cost to the reader, -->
        <!-- which is learning a new syntactic concept for each macro. -->
        <!-- And so it should not be abused. -->
        マクロは構文的抽象をもたらし、これは素晴らしいことです。
        実装の詳細に囚われることなく意図を記述することを可能にし、コードを明確にするのを助けます(まさにそれらの詳細を抽象化します)。
        冗長であったり、無関係であったりする詳細のどちらも省くことで、より簡潔に、より読みやすくすることを助けます。
        しかし、マクロごとに新しい構文概念の学習という読み手への負担をもたらします。
        それ故にマクロは乱用すべきではありません。
      </p>
      <p>
        <!-- The general conclusion is that there shouldn't be -->
        <!-- any recognizable <em>design pattern</em> -->
        <!-- in a good Common Lisp program. -->
        <!-- The one and only pattern is: <em>use the language</em>, -->
        <!-- which includes defining and using syntactic abstractions. -->
        一般的結論として、良いCommon Lispのプログラムの中に、何か<em>デザイン・パターン</em>とされるようなものはない筈です。
        <em>言語を使う</em>のが唯一のパターンであり、これは構文的抽象化の定義と利用を含みます。
      </p>
      <p>
        <!-- Existing macros must be used -->
        <!-- whenever they make code clearer -->
        <!-- by conveying intent in a more concise way, -->
        <!-- which is often. -->
        <!-- When a macro is available in your project -->
        <!-- that expresses the concept you're using, -->
        <!-- you must not write the expansion rather than use the macro. -->
        既存のマクロは、意図をより簡潔に伝えることにより、コードがより明確になる場合であれば、いつでも利用されなければなりません。 <!-- which is oftenってなんなの であればあるほど なのか-->
        マクロがプロジェクトで利用可能な場合で、それがあなたのしたいことを表現できている場合に、そのマクロは利用せず、その展開結果を手書きするようなことをしてはなりません。
      </p>
      <p>
        <!-- New macros should be defined as appropriate, -->
        <!-- which should be seldom, -->
        <!-- for common macros have already been provided -->
        <!-- by the language and its various libraries, -->
        <!-- and your program typically only needs few new ones -->
        <!-- relative to its size. -->
        新しいマクロの定義は適切に、しかし滅多に定義することはないようにすべきです。
        共通で利用されるようなマクロは、既に言語やいくつかのライブラリによって提供されていますし、あなたのプログラムが新しいマクロを必要とすることは通常少しだけです。また、プログラムの小ささに比例して少なくなります。
      </p>
      <p>
        <!-- You should follow the OAOOM rule of thumb -->
        <!-- for deciding when to create a new abstraction, -->
        <!-- whether syntactic or not: -->
        <!-- if a particular pattern is used more than twice, -->
        <!-- it should probably be abstracted away. -->
        <!-- A more refined rule to decide when to use abstraction -->
        <!-- should take into account -->
        <!-- the benefit in term of number of uses and gain at each use, -->
        <!-- to the costs in term of having to get used to reading the code. -->
        <!-- For syntactic abstractions, costs and benefits to the reader -->
        <!-- is usually more important than costs and benefits to the writer, -->
        <!-- because good code is usually written once -->
        <!-- and read many times by many people -->
        <!-- (including the same programmer -->
        <!-- who has to maintain the program after having forgotten it). -->
        <!-- Yet the cost to the writer of the macro -->
        <!-- should also be taken into account; -->
        <!-- however, in doing so it should rather be compared -->
        <!-- to the cost of the programmer writing other code instead -->
        <!-- that may have higher benefits. -->
        新しい構文の抽象化を作成するか否かを判断する際には、大まかな目安として、OAOOM[Once And Only Once More]に従うべきです:
        『もし特定のパターンが二度より多く使われているならば、それは恐らく抽象化されるべきである』 
        抽象化を利用するにあたってのさらに洗練されたルールとして、使われる数とそれら一つ一つがもたらす利益と、コードを読むのに慣れるまでのコストを勘案すべきです。<!-- 厳しい:g000001 -->
        構文の抽象化についての読み手が負担するコストと利益は、通常、書き手が負担するコストと利益より重要なものです。
        なぜなら、良いコードは、通常、書かれるのは一度だけですが、沢山の人々によって何度も読まれるからです。(プログラムの内容を忘れてしまってから保守しなければならないプログラマ本人を含む)
        しかし、[抽象化しないで]代わりのコードを書くコストより、[抽象化した]利益の方が大きいならば、書き手のコストの方が考慮されるべき時もまたあります。<!-- 厳しい:g000001 -->
      </p>
      <p>
        <!-- Using Lisp macros properly requires taste. -->
        <!-- Avoid writing complicated macros -->
        <!-- unless the benefit clearly outweighs the cost. -->
        <!-- It takes more effort for your fellow developers to learn your macro, -->
        <!-- so you should only use a macro if the gain in expressiveness -->
        <!-- is big enough to justify that cost. -->
        <!-- As usual, feel free to consult your colleagues if you're not sure, -->
        <!-- since without a lot of Lisp experience, -->
        <!-- it can be hard to make this judgment. -->
        Lispのマクロの利用は、分別を弁えて。
        [複雑にすることによる]恩恵がそのコストを明確に上回ることがない限り、複雑なマクロを書くのは避けましょう。
        同僚の開発者があなたのマクロを理解するのにより多くの労力を使うことになるため、理解のコストに十分見合うだけの分かりやすさを持つ場合だけ[複雑な]マクロを使用すべきです。
        判断がつかない場合には、いつでも同僚に遠慮しないで助言を求めましょう。
        Lispの多くの経験を積んでいなければ、この判断は難しいものだからです。
      </p>
      <p>
        <!-- You must never use a macro where a function will do. -->
        <!-- That is, if the semantics of what you are writing -->
        <!-- conforms to the semantics of a function, -->
        <!-- then you must write it as a function rather than a macro. -->
        関数で目的を果せるところでマクロを使ってはなりません。
        つまり、あなたが書こうとしているものの意味論が、関数の意味論に適合しているならば、マクロではなく、関数で書かなくてはならない、ということです。
      </p>
      <p>
        <!-- You must not transform a function into a macro for performance reasons. -->
        <!-- If profiling shows that you have a performance problem -->
        <!-- with a specific function <code>FOO</code>, -->
        <!-- document the need and profiling-results appropriately, -->
        <!-- and -->
        <!-- <code>(declaim (inline foo))</code>. -->
        パフォーマンス上の理由で関数をマクロに書き直してはなりません。
        プロファイリングの結果が、特定の関数<code>FOO</code>にパフォーマンス上の問題があることを示したとすれば、その必要性と適切なプロファイリングの結果を文章化した上で、<code>(declaim (inline foo))</code>を宣言します。
      </p>
      <p>
        <!-- You can also use a compiler-macro -->
        <!-- as a way to speed up function execution -->
        <!-- by specifying a source-to-source transformation. -->
        <!-- Beware that it interferes with tracing the optimized function. -->
        また、関数の実行の速度向上の方法として、ソースコードからソースコードへの変換手順を指定するコンパイラ・マクロを使うこともできるでしょう。
        ただし、これは最適化された関数をトレースする場合には邪魔になることに用心しておきましょう。
      </p>
      <p>
        <!-- When you write a macro-defining macro -->
        <!-- (a macro that generates macros), -->
        <!-- document and comment it particularly clearly, -->
        <!-- since these are harder to understand. -->
        マクロを書くマクロ(マクロを定義するマクロ)を書く場合には、とりわけ分かりやすくドキュメントとコメントを書きましょう。
        慣れない人には、これらはとても分かり難いものだからです。
      </p>
      <p>
        <!-- You must not install new reader macros -->
        <!-- without a consensus among the developers of your system. -->
        <!-- Reader macros must not leak out of the system that uses them -->
        <!-- to clients of that system or other systems used in the same project. -->
        <!-- You must use software such as -->
        <!-- <code>cl-syntax</code> or <code>named-readtables</code> -->
        <!-- to control how reader macros are used. -->
        <!-- This clients who desire it may use the same reader macros as you do. -->
        <!-- In any case, your system must be usable -->
        <!-- even to clients who do not use these reader macros. -->
        携わっているシステムの開発者間での合意なしに、新しいリーダーマクロを導入してはなりません。
        リーダーマクロ[の影響範囲]がシステムを使う側や、同じプロジェクトの他のシステムに漏れ出すようなことがあってはなりません。
        リーダーマクロの利用を制御するためには、<code>cl-syntax</code>や<code>named-readtables</code>のようなソフトウェアを使わなければなりません。
        [システムを]使う側は、あなたと同じように同じリーダーマクロを使うかもしれませんが、どうであれ、システムは、リーダーマクロを使わない利用者でも[リーダーマクロを使う場合と]同じように使えるものであらなくてはなりません。
      </p>
      <p>
        <!-- If your macro has a parameter that is a Lisp form -->
        <!-- that will be evaluated when the expanded code is run, -->
        <!-- you should name the parameter with the suffix <code>-form</code>. -->
        <!-- This convention helps make it clearer to the macro's user -->
        <!-- which parameters are Lisp forms to be evaluated, and which are not. -->
        もしマクロが、マクロが展開された後に、Lispの式として評価されるような引数を持っている場合、その引数には、<code>-form</code>という接尾辞を付けた名前を付けるべきです。
        この取り決めは、マクロの利用者から見てどの引数がLispの式として展開され、またそうでないのかを、より分かりやすくします。
      </p>
      <p>
        <!-- You should follow the so-called <code>CALL-WITH</code> style when it applies. -->
        <!-- This style is explained at length in -->
        <!-- <a href="http://random-state.net/log/3390120648.html">http://random-state.net/log/3390120648.html</a>. -->
        <!-- The general principle is that the macro is strictly limited to processing the syntax, -->
        <!-- and as much of the semantics as possible is kept in normal functions. -->
        <!-- Therefore, a macro <code>WITH-<em>FOO</em></code> is often limited to -->
        <!-- generating a call to an auxiliary function -->
        <!-- <code>CALL-WITH-<em>FOO</em></code> -->
        <!-- with arguments deduced from the macro arguments. -->
        <!-- Macro <code>&amp;body</code> arguments are typically -->
        <!-- wrapped into a lambda expression of which they become the body, -->
        <!-- which is passed as one of the arguments of the auxiliary function. -->
        適用できる場合は、<code>CALL-WITH</code>スタイルと呼ばれるスタイルに倣うべきです。
        このスタイルは、<a href="http://random-state.net/log/3390120648.html">http://random-state.net/log/3390120648.html</a>で詳細に説明されています。
        一般的原理としては、マクロは構文の処理に限定して用い、意味論はできる限り通常の関数内に保ったままにしておくというものです。
        つまり、大体のところ<code>WITH-<em>FOO</em></code>というマクロは、<code>CALL-WITH-<em>FOO</em></code>というマクロの引数から加工された引数を持つ補助関数の呼び出しを生成するためだけのものということです。
        マクロの<code>&amp;body</code>引数は、典型的には、補助関数に与えられる引数の一つとしてのラムダ式で、ラムダ式のボディ部となるところにまとめられます。
      </p>
      <p>
        <!-- The separation of syntactic and semantic concerns -->
        <!-- is a general principle of style that applies -->
        <!-- beyond the case of <code>WITH-</code> macros. -->
        構文的な関心と意味論的な関心の分離は、<code>WITH-</code>の事例を敷衍し、スタイルの一般的原理としたものです。
        <!-- Its advantages are many. -->
        この手法には沢山のアドバンテージがあります。
        <!-- By keeping semantics outside the macro, -->
        <!-- the macro is made simpler, easier to get right, and less subject to change, -->
        <!-- which makes it easier to develop and maintain. -->
        意味論をマクロの外側に保持することにより、マクロは、より単純で、分かりやすく、変更の影響を受けにくくなり、開発と保守が容易になります。        
 	<!-- The semantics is written in a simpler language — one without staging — -->
        <!-- which also makes it easier to develop and maintain. -->
        意味論は、土台なしのより単純な言語で書かれますが、そのことがまた、開発と保守を容易にします。<!-- one without staging ?? -->
        <!-- It becomes possible to debug and update the semantic function -->
        <!-- without having to recompile all clients of the macro. -->
        この手法は、マクロを利用するものを再コンパイルすることなしに意味論を担当する関数のデバッグと更新を可能にします。
        <!-- The semantic function appears in the stack trace -->
        <!-- which also helps debug client functions. -->
        意味論を担当する関数は、スタックトレース中で見えるため、これを利用している関数のデバッグの助けにもなります。
        <!-- The macro expansion is made shorter and -->
        <!-- each expansion shares more code with other expansions, -->
        <!-- which reduces memory pressure which in turn usually makes things faster. -->
        マクロ展開は、より短かくなり、また、各展開は、他の展開と共有する部分もより多くなるため、メモリへの圧迫も少なくなり、大抵速くなります。
        <!-- It also makes sense to write the semantic functions first, -->
        <!-- and write the macros last as syntactic sugar on top. -->
        また、この手法は、意味論を担当する関数を先に書き、その後でその上に糖衣構文としてマクロを書く、という理にかなった筋道を与えます。
        <!-- You should use this style unless the macro is used -->
        <!-- in tight loops where performance matters; -->
        <!-- and even then, see our rules regarding optimization. -->
        このスタイルは、マクロが、タイトループ内のようなパフォーマンスが重要な場所以外で適用するべきです(最適化の項を参照してください)。
      </p>
      <p>
        <!-- Any functions (closures) created by the macro should be named, -->
        <!-- which can be done using <code>FLET</code>. -->
        
        <!-- This also allows you to declare the function to be of dynamic extent -->
        <!-- (if it is — and often it is; yet see below regarding -->
        <!-- <a href="#DYNAMIC-EXTENT">DYNAMIC-EXTENT</a>). -->
        マクロによって作られる関数(クロージャー)は、名前を持つべきです。
        これは、<code>FLET</code>を使うことによって可能です。
        これはまた、関数のDYNAMIC-EXTENT宣言を可能にします。
        (必要に応じて下記の<a href="#DYNAMIC-EXTENT">DYNAMIC-EXTENT</a>の項を参照してください)
      </p>
      <p>
        <!-- If a macro call contains a form, -->
        <!-- and the macro expansion includes more than one copy of that form, -->
        <!-- the form can be evaluated more than once, -->
        <!-- and code it contains macro-expanded and compiled more than once. -->
        <!-- If someone uses the macro and calls it -->
        <!-- with a form that has side effects or that takes a long time to compute, -->
        <!-- the behavior will be undesirable -->
        <!-- (unless you're intentionally writing -->
        <!-- a control structure such as a loop). -->
        <!-- A convenient way to avoid this problem -->
        <!-- is to evaluate the form only once, -->
        <!-- and bind a (generated) variable to the result. -->
        <!-- There is a very useful macro called <code>ALEXANDRIA:ONCE-ONLY</code> -->
        <!-- that generates code to do this. -->
        <!-- See also <code>ALEXANDRIA:WITH-GENSYMS</code>, -->
        <!-- to make some temporary variables in the generated code. -->
        <!-- Note that if you follow our <code>CALL-WITH</code> style, -->
        <!-- you typically expand the code only once, as either -->
        <!-- an argument to the auxiliary function, or -->
        <!-- the body of a lambda passed as argument to it; -->
        <!-- you therefore avoid the above complexity. -->
        マクロが、ある一つのフォームを含んでいて、
        マクロの展開により、そのフォームがマクロ中に複数のコピーを作るという場合、
        そのフォームは、複数回評価され得ることになります。
        また、コードは、複数回マクロ展開やコンパイルされたものを含むことになります。
        もし誰かがこのマクロ使い、その中で、副作用を利用していたり、長時間の計算をさせていた場合、この振舞いは望ましくないものでしょう(故意にあなたがループのような制御構文を書いているのでもない限り)。
        この問題を避ける手短な解決策は、フォームの評価は一度きりにして、その結果を(生成した)変数に束縛することです。
        このようなコードを生成するのには、
        <code>ALEXANDRIA:ONCE-ONLY</code>というとても便利なマクロがあります。
        また、コード生成内で一時的な変数を生成するのには、<code>ALEXANDRIA:WITH-GENSYMS</code>を参照してください。
        我々の<code>CALL-WITH</code>スタイルに従うならば、
        典型的には、マクロの展開は、補助関数への引数も、補助関数に渡されるボディ部も同じく一度きりであり、従って上述の複雑さも回避することになる、ということに留意しておきましょう。
      </p>
      <p>
        <!-- When you write a macro with a body, -->
        <!-- such as a <code>WITH-xxx</code> macro, -->
        <!-- even if there aren't any parameters, -->
        <!-- you should leave space for them anyway. -->
        <!-- For example, if you invent <code>WITH-LIGHTS-ON</code>, -->
        <!-- do not make the call to it look like -->
        <!-- <code>(defmacro with-lights-on (&amp;body b) ...)</code>. -->
        <!-- Instead, do <code>(defmacro with-lights-on (() &amp;body b) ...)</code>. -->
        <!-- That way, if parameters are needed in the future, -->
        <!-- you can add them without necessarily having to change -->
        <!-- all the uses of the macro. -->
        <code>WITH-xxx</code>のようなボディ部を持ったマクロを書く場合には、
	引数を取ることがなくても、とりあえず、その為の場所は確保して置くべきです。
        例を挙げると、<code>WITH-LIGHTS-ON</code>を作成しているとすれば、
        <code>(defmacro with-lights-on (&amp;body b) ...)</code>のような形式にはせず、
        代りに、<code>(defmacro with-lights-on (() &amp;body b) ...)</code>のような形式にしましょう。
        この方式であれば、将来、引数が必要になった場合、
	利用中の全部のマクロを変更する必要とは無縁に引数の追加が可能になります。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="EVAL-WHEN">
    <SUMMARY>
      <!-- When using <code>EVAL-WHEN</code>, you should almost always use all of -->
      <!-- <code>(:compile-toplevel :load-toplevel :execute)</code>. -->
      <code>EVAL-WHEN</code>を使用する場合には、ほぼ必ず
      <code>(:compile-toplevel :load-toplevel :execute)</code>の
      すべてのオプションを付けて使用するべきです。
    </SUMMARY>
    <BODY>
      <p>
        <!-- Lisp evaluation happens at several times, -->
        <!-- some of them interleaved. -->
        <!-- Be aware of them when writing macros. -->
	Lispでの「評価」は複数回行われる可能性があり、時には評価の順番が入れ替わる時もあります。
	マクロを書くときには注意しましょう。
        <!-- <a href="http://fare.livejournal.com/146698.html"> -->
	<!--   EVAL-WHEN considered harmful to your mental health</a>. -->
        <a href="http://fare.livejournal.com/146698.html">
	  「EVAL-WHEN はあなたの精神衛生を害する」</a>.
      </p>
      <p>
        <!-- In summary of the article linked above, -->
        <!-- unless you're doing truly advanced macrology, -->
        <!-- the only valid combination in an <code>EVAL-WHEN</code> -->
        <!-- is to include all of -->
        <!-- <code>(eval-when (:compile-toplevel :load-toplevel :execute) ...)</code> -->
	上記にリンクした先の記事を要約すると、
        基本的に<code>(eval-when (:compile-toplevel :load-toplevel :execute) ...)</code>
	以外の<code>EVAL-WHEN</code>コードはよくない、という事です。
	例外はマクロを書く<i>本当に</i>優れた技術を持っている場合のみです。
      </p>
      <p>
        <!-- You must use -->
        <!-- <code>(eval-when (:compile-toplevel :load-toplevel :execute) ...)</code> -->
        <!-- whenever you define functions, types, classes, constants, variables, etc., -->
        <!-- that are going to be used in macros. -->
	マクロの中で使う関数や型、クラス、定数、変数などはすべて
        <code>(eval-when (:compile-toplevel :load-toplevel :execute) ...)</code>の中で書かなくてはなりません。
      </p>
      <p>
        <!-- It is usually an error to omit the <code>:execute</code>, -->
        <!-- because it prevents <code>LOAD</code>ing the source rather than the fasl. -->
        <!-- It is usually an error to omit the <code>:load-toplevel</code> -->
        <!-- (except to modify e.g. readtables and compile-time settings), -->
        <!-- because it prevents <code>LOAD</code>ing future files -->
        <!-- or interactively compiling code -->
        <!-- that depends on the effects that happen at compile-time, -->
        <!-- unless the current file was <code>COMPILE-FILE</code>d -->
        <!-- within the same Lisp session. -->
	下記の事項はエラーの原因になります。
	<ul>
	  <li><code>:execute</code>を省くこと :
	  faslではなくソース[ファイル]の<code>LOAD</code>を妨げてしまうため。</li>
	  <li><code>:load-toplevel</code>を省くこと (readtableの編集やコンパイル時の設定を除く):
	  コードの動的コンパイルや遅延評価でコンパイルされるソースを<code>LOAD</code>できなくなるため。
	  もし省くと、動的コンパイルをする時にそれらコンパイル時の効果を使えなくなる。
	  ただし、それらのソースが<code>COMPILE-FILE</code>でコンパイルされているときは例外。
	  </li>
	</ul>
      </p>
      <p>
        <!-- Regarding variables, note that because macros may or may not -->
        <!-- be expanded in the same process that runs the expanded code, -->
        <!-- you must not depend on compile-time and runtime effects -->
        <!-- being either visible or invisible at the other time. -->
        <!-- There are still valid uses of variables in macros: -->
	変数について。マクロを展開するプロセスと展開コードを実行するプロセスは別かもしれません。
	そのため、コンパイル時と実行時で、それぞれの効果が依存しあってはいけません。
	ただし、許容される使用方法もあります:
       </p>
      <ul>
        <li>
          <!-- Some variables may hold dictionaries -->
          <!-- for some new kind of definition and other meta-data. -->
          <!-- If such meta-data is to be visible at runtime and/or in other files, -->
          <!-- you must make sure that the macro expands into code that -->
          <!-- will register the definitions to those meta-data structures -->
          <!-- at load-time, -->
          <!-- in addition to effecting the registration at compile-time. -->
          <!-- Typically, your top-level definitions expand -->
          <!-- to code that does the registration. -->
          <!-- if your code doesn't expand at the top-level, -->
          <!-- you can sometimes use <code>LOAD-TIME-VALUE</code> for good effect. -->
          <!-- In extreme cases, you may have to use -->
          <!-- <code>ASDF-FINALIZERS:EVAL-AT-TOPLEVEL</code>. -->
	  新種の「定義」系データ・メタデータを辞書テーブルに保存する場合。
	  <!-- defunやdefclassのこと :: guicho271828 -->
	  もしそれらのメタデータが実行時に扱えるものなら、
	  定義マクロの展開結果において、
	  データを辞書テーブルに登録する実際の動作は
	  コンパイル時だけでなくロード時にも指定しなくてはならない。
	  通常、トップレベルでの定義は登録を行うコードに展開される。
	  トップレベル以外で展開される場合は、<code>LOAD-TIME-VALUE</code>を使っても良い。
	  極端な場合では、<code>ASDF-FINALIZERS:EVAL-AT-TOPLEVEL</code>
	  を使わざるを得ない場合もあるだろう。
        </li>
        <li>
          <!-- Some variables may hold temporary data -->
          <!-- that is only used at compile-time in the same file, -->
          <!-- and can be cleaned up at the end of the file's compilation. -->
	  変数によっては、同ファイル内かつコンパイル時にしか使われないような
	  一時データを保持していることもあるだろう。
	  それらはコンパイルの終了と共に掃除・消去されることもありうる。
          <!-- Predefined such variables would include <code>*readtable*</code> -->
          <!-- or compiler-internal variables holding -->
          <!-- the current optimization settings. -->
          <!-- You can often manage existing and new such variables using -->
          <!-- the <code>:AROUND-COMPILE</code> hooks of <code>ASDF</code>. -->
	  定義済みのそういった変数には<code>*readtable*</code>や
	  最適化設定を保持しているコンパイラ内部変数などが上げられる。
	  これらのような変数を操作したり新たに作るためには、
	  <code>ASDF</code>の<code>:AROUND-COMPILE</code>を使える。
        </li>
      </ul>
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="Read-time evaluation"> -->
  <STYLEPOINT title="読み取り時評価">
    <SUMMARY>
      <!-- You should use <code>#.</code> sparingly, -->
      <!-- and you must avoid read-time side-effects. -->
      <code>#.</code> の利用は控え目にすべきです。
      また、読み取り時に起こす副作用の利用は控えなくてはなりません。
    </SUMMARY>
    <BODY>
      <p>
        <!-- The <code>#.</code> standard read-macro -->
        <!-- will read one object, evaluate the object, and -->
        <!-- have the reader return the resulting value. -->
        ANSI標準のリードマクロ<code>#.</code>は、
	その先のオブジェクトをひとつ読み、これを評価して、評価機にその結果を返させます。
      </p>
      <p>
        <!-- You must not use it where other idioms will do, such as -->
        <!-- using <code>EVAL-WHEN</code> to evaluate side-effects at compile-time, -->
        <!-- using a regular macro to return an expression computed at compile-time, -->
        <!-- using <code>LOAD-TIME-VALUE</code> to compute it at load-time. -->
	他の手段が適しているときにこの機能を使ってはいけません。
        <code>EVAL-WHEN</code>を使えばコンパイル時の副作用を使えます。
	マクロを使えばコンパイル時にコードを生成できます。
	<code>LOAD-TIME-VALUE</code>を使えばロード時に生成できます。
      </p>
      <p>
        <!-- Read-time evaluation is often used as a quick way -->
        <!-- to get something evaluated at compile time -->
        <!-- (actually "read time" but it amounts to the same thing). -->
	読み取り時評価はコンパイル時評価を行う手軽な方法として使われることがあります
	(「読み取り時」とはいいますがまあコンパイル時とほぼ同じてみてよいでしょう)。
        <!-- If you use this, the evaluation MUST NOT have any side effects -->
        <!-- and MUST NOT depend on any variable global state. -->
        <!-- The <code>#.</code> should be treated as a way -->
        <!-- to force "constant-folding" -->
        <!-- that a sufficiently-clever compiler -->
        <!-- could have figure out all by itself, -->
        <!-- when the compiler isn't sufficiently-clever -->
        <!-- and the difference matters. -->
	しかしこれを使うなら、評価は副作用を持ってはならず、
	大域変数に依存してもなりません。
	<code>#.</code>は「定数のたたみ込み」を
	コンパイラのかわりに指定する方法としてのみ使うべきです。
	本来は「十分に賢いコンパイラ」ならそれら定数たたみ込みを自分で判断できるはずですが、
	現実にはそうではありません。そして、その違いが問題となる場合には
	<code>#.</code>が必要です。
      </p>
      <p>
        <!-- Another use of <code>#.</code> is to expand the equivalent of macros -->
        <!-- in places that are neither expressions nor (quasi)quotations, -->
        <!-- such as lambda-lists. However, if you find yourself using it a lot, -->
        <!-- it might be time to instead define macros to replace your consumers -->
        <!-- of lambda-lists with something that recognizes an extension. -->
	<code>#.</code>のもうひとつの用法は、式でも(quasi)quotationでもない部分に
	マクロを展開することです。たとえば変数リストの中など。
	しかし、それを何度も使うようなら、それ用にマクロを書くべきでしょう。
      </p>
      <p>
        <!-- Whenever you are going to use <code>#.</code>, -->
        <!-- you should consider using <code>DEFCONSTANT</code> and its variants, -->
        <!-- possibly in an <code>EVAL-WHEN</code>, -->
        <!-- to give the value a name explaining what it means. -->
	最後に、<code>#.</code>を使う時のtips。
	使う前に一度は<code>DEFCONSTANT</code>系マクロを
	使うことを検討してみましょう(<code>EVAL-WHEN</code>内で)。
	そうすれば、<code>#.</code>で作った定数に名前を与えられます。
        <!-- 上記なんですが、#.と、defconstantの組み合わせという具体的な方法が
             思い付かないのですが、
             #.を使う前に、defconstantで書けるものでないかを良く考えて判断しよう、
             ということではないんですかね？ g000001 -->
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="EVAL">
    <SUMMARY>
      <!-- You must not use <code>EVAL</code> at runtime. -->
      実行時に<code>EVAL</code>を使ってはなりません。
    </SUMMARY>
    <BODY>
      <p>
        <!-- Places where it is actually appropriate to use <code>EVAL</code> -->
        <!-- are so few and far between that you must consult with your reviewers; -->
        <!-- it's easily misused. -->
        <code>EVAL</code>を使うことが真に適切であるという極まれな場面でも、
        あなたはあなたの査読者と相談しなければなりません。
        EVALは容易に誤用されるからです。
      </p>
      <p>
        <!-- If your code manipulates symbols at runtime -->
        <!-- and needs to get the value of a symbol, -->
        <!-- use <code>SYMBOL-VALUE</code>, not <code>EVAL</code>. -->
        もしもあなたのコードが、実行時にシンボルを操作し、
        シンボルの値を取得することを必要とするときは
        <code>EVAL</code>ではなく<code>SYMBOL-VALUE</code>を使いましょう。
      </p>
      <p>
        <!-- Often, what you really need is to write a macro, -->
        <!-- not to use <code>EVAL</code>. -->
        良くあること: あなたが本当に必要としていることは「マクロを書く」ことで「<code>EVAL</code>を使う」ことではありません。
      </p>
      <p>
        <!-- You may be tempted to use <code>EVAL</code> as a shortcut -->
        <!-- to evaluating expressions in a safe subset of the language. -->
        言語の安全なサブセット内において、式を評価するときの近道として、<code>EVAL</code>
        を利用する誘惑にかられるかもしれません。
        <!-- But it often requires more scrutiny to properly check and sanitize -->
        <!-- all possible inputs to such use of <code>EVAL</code> -->
        <!-- than to build a special-purpose evaluator. -->
        <!-- You must not use <code>EVAL</code> in this way at runtime. -->
        しかし、大抵の場合、特殊用途の評価器をつくりあげるよりも<code>EVAL</code>を使う方が、
        すべての入力の可能性について有効性と安全を保つための監視の手間が増えます。
        このような場合、<code>EVAL</code>は使わないようにしないとなりません。
      </p>
      <p>
        <!-- Places where it is OK to use <code>EVAL</code> are: -->
        <code>EVAL</code>を使うことが許される状況を以下に記します。
      </p>
      <ul>
        <li>
          <!-- Implementing an interactive development loop. -->
          インタラクティブな開発のためのループの実装。
        </li>
        <li>
          <!-- The build infrastructure. -->
          基盤の構築。
        </li>
        <li>
          <!-- Backdoors that are part of testing frameworks. -->
          <!-- (You MUST NOT have such backdoors in production code.) -->
          テストフレームワークにおけるバックドア
          (実用コードにおいてこの手のバックドアを設けてはなりません)。
        </li>
        <li>
          <!-- Macros that fold constants at compile-time. -->
          コンパイル時に定数をたたみ込むマクロ。
        </li>
        <li>
          <!-- Macros that register definitions to meta-data structures; -->
          メタデータ構造のための定義を登録するマクロ。
          <!-- the registration form is sometimes evaluated at compile-time -->
          <!-- as well as included in the macro-expansion, -->
          <!-- so it is immediately available to other macros. -->
          登録を行うフォームは時にコンパイル時に評価、もしくは、マクロ展開で組み込まれるので、
          即座に他のマクロから利用可能になります。
        </li>
      </ul>
      <p>
        <!-- Note that in the latter case, -->
        <!-- if the macro isn't going to be used at the top-level, -->
        <!-- it might not be possible to make these definitions available -->
        <!-- as part of the expansion. --> <!-- g000001: なんとなく分かりますが具体的にどういうコードになるのか想像できないですね -->
        注記: 後の例<!-- マクロ展開時のことを指している? g000001 -->において、もしマクロがトップレベルで使用できる状態にならない場合、
        展開の一部分である定義が展開されず、[結果として]それらの定義も有効にならない可能性があるということに注意が必要です。 
        <!-- The same phenomenon may happen in a <code>DEFTYPE</code> expansion, -->
        <!-- or in helper functions used by macros. -->
        同じような現象は<code>DEFTYPE</code>での展開や、
        マクロに利用されるヘルパ関数においても起こります。
        <!-- In these cases, you may actually have to use -->
        <!-- <code>ASDF-FINALIZERS:EVAL-AT-TOPLEVEL</code> in your macro. -->
	こういった場合、マクロ内において、
	<code>ASDF-FINALIZERS:EVAL-AT-TOPLEVEL</code>を使う必要が実際にあるかもしれません。
        <!-- It will not only <code>EVAL</code> your definitions -->
        <!-- at macro-expansion time for immediate availability, -->
        <!-- it will also save the form aside, for inclusion in a -->
        <!-- <code>(ASDF-FINALIZERS:FINAL-FORMS)</code> -->
        <!-- that you need to include at the end of the file being compiled -->
        <!-- (or before the form is needed). -->
        これは、マクロ展開時に、フォームを<code>EVAL</code>し、即時に有効化するだけでなく、
        ファイルがコンパイルされる時にファイルの末尾に置く必要があるものとして(もしくは、そのフォームが必要とされる前に)、
        <code>(ASDF-FINALIZERS:FINAL-FORMS)</code> が含めるフォームとして取っておきます。        
        <!-- This way, the side-effects are present when loading the fasl --><!-- faslはコンパイルされてると思うのでfileの間違い?: g000001 -->
        <!-- without having compiled it as well as while compiling it; -->
        この方法は、コンパイルしたfasl[ファイル?]においてもしないものにおいても副作用を持っています。
        <!-- in either case, the form is made available at load-time. -->
        どちらの場合も、フォームはロード時に使えるようになります。
        <!-- <code>ASDF-FINALIZERS</code> ensures that the form is present, -->
        <!-- by throwing an error if you omit it. -->
        <code>ASDF-FINALIZERS</code>はフォームが存在することを保証し、[フォームを]省略した場合はエラーを投げます。
      </p>
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="INTERN and UNINTERN"> -->
  <STYLEPOINT title="INTERNとUNINTERN">
    <SUMMARY>
      <!--
      You must not use <code>INTERN</code> or <code>UNINTERN</code> at runtime. 
      -->
      実行時に<code>INTERN</code>と<code>UNINTERN</code>は使用してはなりません。
    </SUMMARY>
    <BODY>
      <p>
        <!-- You must not use <code>INTERN</code> at runtime. -->
        <!-- Not only does it cons, -->
        <!-- it either creates a permanent symbol that won't be collected -->
        <!-- or gives access to internal symbols. -->
        <!-- This creates opportunities for memory leaks, denial of service attacks, -->
        <!-- unauthorized access to internals, clashes with other symbols. -->
        <code>INTERN</code>を実行時に使用してはなりません。
        これは[GCに]回収されない恒久的なシンボルの生成であろうと、内部シンボルの生成であろうと良くありません。
        <!-- pros and consのconsか、それともはboxingのことか、それとも「construct」の意味か -g000001 -->
        これらの実行は、メモリリーク・DoS攻撃・内部への不正アクセス・他のシンボルとの競合、等の発生を生む可能性があります。
      </p>
      <p>
        <!-- You must not <code>INTERN</code> a string -->
        <!-- just to compare it to a keyword; -->
        <!-- use <code>STRING=</code> or <code>STRING-EQUAL</code>. -->
        単にキーワード[シンボル]を比較するためだけに、文字列を<code>INTERN</code>してはなりません。
        <code>STRING=</code>か<code>STRING-EQUAL</code>を使いましょう。
      </p>
      <BAD_CODE_SNIPPET>
        (member (intern str :keyword) $keys) ; 悪い
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (member str $keys :test #'string-equal) ; より良い
      </CODE_SNIPPET>
      <p>
        <!-- You must not use <code>UNINTERN</code> at runtime. -->
        <!-- It can break code that relies on dynamic binding. -->
        <!-- It makes things harder to debug. -->
        <!-- You must not dynamically intern any new symbol, -->
        <!-- and therefore you need not dynamically unintern anything. -->
        <code>UNINTERN</code>を実行時に使用してはなりません。
        これは、動的な束縛に依存したコードを破壊する可能性があります。
        また、これは、デバッグを困難なものにします。
        動的に新しいシンボルを<code>INTERN</code>してはなりませんし、そうなると、まったく動的にシンボルを<code>UNINTERN</code>する必要もありません。<!-- un/internは別個のものでは？ -g000001 -->
      </p>
      <p>
        <!-- You may of course use <code>INTERN</code> at compile-time, -->
        <!-- in the implementation of some macros. -->
        <!-- Even so, it is usually more appropriate -->
        <!-- to use abstractions on top of it, such as -->
        <!-- <code>ALEXANDRIA:SYMBOLICATE</code> or -->
        <!-- <code>ALEXANDRIA:FORMAT-SYMBOL</code> -->
        <!-- to create the symbols you need. -->
        勿論、コンパイル時には、マクロの組み立ての中で<code>INTERN</code>は使えるでしょう。
        とはいえ、大抵は[<code>INTERN</code>を直に使うより]、それを抽象化したものを使うのがより適切であり、
        必要なシンボルを生成するのには<code>ALEXANDRIA:SYMBOLICATE</code>や<code>ALEXANDRIA:FORMAT-SYMBOL</code>のようなものを使うことでしょう。
      </p>
    </BODY>
  </STYLEPOINT>
</CATEGORY>
<!-- <CATEGORY title="Data Representation"> -->
<CATEGORY title="データ表現">
  <!-- <STYLEPOINT title="NIL: empty-list, false and I Don't Know"> -->
  <STYLEPOINT title="NIL: 空リスト、偽値、なにやら分からない値">
    <SUMMARY>
      <!-- Appropriately use or avoid using <code>NIL</code>. -->
      <code>NIL</code>の使用/不使用は適切に行ないましょう。
    </SUMMARY>
    <BODY>
      <p>
        <code>NIL</code> can have several different interpretations:
      </p>
      <ul>
        <li>
          "False."
          In this case, use <code>NIL</code>.
          You should test for false <code>NIL</code>
          using the operator <code>NOT</code> or
          using the predicate function <code>NULL</code>.
        </li>
        <li>
          "Empty-list."
          In this case, use <code>'()</code>.
          (Be careful about quoting the empty-list when calling macros.)
          You should use <code>ENDP</code> to test for the empty list
          when the argument is known to be a proper list,
          or with <code>NULL</code> otherwise.
        </li>
        <li>
          A statement about some value being unspecified.
          In this case, you may use <code>NIL</code>
          if there is no risk of ambiguity anywhere in your code;
          otherwise you should use an explicit, descriptive symbol.
        </li>
        <li>
          A statement about some value being known not to exist.
          In this case, you should use an explicit, descriptive symbol
          instead of <code>NIL</code>.
        </li>
      </ul>
      <p>
        You must not introduce ambiguity in your data representations
        that will cause headaches for whoever has to debug code.
        If there is any risk of ambiguity,
        you should use an explicit, descriptive symbol or keyword
        for each case,
        instead of using <code>NIL</code> for either.
        If you do use <code>NIL</code>,
        you must make sure that the distinction is well documented.
      </p>
      <p>
        In many contexts,
        instead of representing "I don't know" as a particular value,
        you should instead use multiple values,
        one for the value that is known if any,
        and one to denote whether the value was known or found.
      </p>
      <p>
        When working with database classes, keep in mind that
        <code>NIL</code> need not always map to <code>'NULL'</code>
        (and vice-versa)!
        The needs of the database may differ from the needs of the Lisp.
      </p>
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="Do not abuse lists"> -->
  <STYLEPOINT title="リストの乱用はしない">
    <SUMMARY>
      <!-- You must select proper data representation. 
           You must not abuse the LIST data structure.  -->
      *絶対に*データ表現は正しく選択すべきです。
      *絶対に*<code>LIST</code>構造を乱用すべきではありません。
    </SUMMARY>
    <BODY>
      <p>
        Even though back in 1958, LISP was short for "LISt Processing",
        its successor Common Lisp has been a modern programming language
        with modern data structures since the 1980s.
        You must use the proper data structures in your programs.
      </p>
      <p>
        You must not abuse the builtin (single-linked) <code>LIST</code>
        data structure where it is not appropriate,
        even though Common Lisp makes it especially easy to use it.
      </p>
      <p>
        You must only use lists
        when their performance characteristics
        is appropriate for the algorithm at hand:
        sequential iteration over the entire contents of the list.
      </p>
      <p>
        An exception where it is appropriate to use lists
        is when it is known in advance
        that the size of the list will remain very short
        (say, less than 16 elements).
      </p>
      <p>
        List data structures are often (but not always)
        appropriate for macros and functions used by macros at compile-time:
        indeed, not only is source code passed as lists in Common Lisp,
        but the macro-expansion and compilation processes
        will typically walk over the entire source code, sequentially, once.
        (Note that advanced macro systems don't directly use lists, but instead
        use abstract syntax objects that track source code location and scope;
        however there is no such advanced macro system
        in Common Lisp at this time.)
      </p>
      <p>
        Another exception where it is appropriate to use lists is
        for introducing literal constants
        that will be transformed into more appropriate data structures
        at compile-time or load-time.
        It is a good to have a function with a relatively short name
        to build your program's data structures from such literals.
      </p>
      <p>
        In the many cases when lists are not the appropriate data structure,
        various libraries such as
        <a href="http://cliki.net/cl-containers">cl-containers</a> or
        <a href="http://cliki.net/lisp-interface-library">lisp-interface-library</a>
        provide plenty of different data structures
        that should fulfill all the basic needs of your programs.
        If the existing libraries are not satisfactory, see above about
        <a href="#Using_Libraries">Using Libraries</a> and
        <a href="#Open-Sourcing_Code">Open-Sourcing Code</a>.
      </p>
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="Lists vs. structures vs. multiple values"> -->
  <STYLEPOINT title="リストか構造体か多値か">
    <SUMMARY>
      <!-- You should use the appropriate representation for product types. -->
      作るものに応じて適材適所で用いる<!-- SOULD -->べきです。 
    </SUMMARY>
    <BODY>
      <p>
        You should avoid using a list as anything besides a container of elements of like type.
        <!-- リストをなにか似たようなタイプもの入れ物として使うことからそれて使うべきではありません。??? -->
        You must not use a list as method of passing multiple separate values of different types in and out of function calls.
        <!-- リストを関数の手法として使ってはなりません。 -->
        <!-- Sometimes it is convenient to use a list as a little ad hoc structure, -->
        時にはリストを少しアドホックな構造体と見做して使うのも便利でしょう。
        <!-- i.e. "the first element of the list is a FOO, and the second is a BAR", -->
        すなわち、"そのリストの最初の第一の要素はFOO、そして第二はBARとする"、のように。
        <!-- but this should be used minimally since it gets harder to remember the little convention. -->
        しかし、このような使い方は最小限であるべきて、なぜならこのような細々とした取り決めを思い出すのは難しいからです。
        You must only use a list that way when destructuring the list of arguments from a function,
        or creating a list of arguments to which to <code>APPLY</code> a function.
      </p>
      <p>
        The proper way to pass around an object
        comprising several values of heterogeneous types
        is to use a structure as defined by <code>DEFSTRUCT</code>
        or <code>DEFCLASS</code>.
      </p>
      <p>
        <!-- You should use multiple values only -->
        <!-- when function returns a small number of values -->
        <!-- that are meant to be destructured immediately by the caller, -->
        <!-- rather than passed together as arguments to further functions. -->
        多値の利用は、関数が少数の値を返し、[これらの値が、]呼び出し側よりさらに先の関数に引数などとして一緒に渡されたりするよりは寧ろ、呼び出し側によって値が即座に分解されるように使われる場合に限るべきです。
      </p>
      <p>
        <!-- You should not return a condition object -->
        <!-- as one of a set of multiple values. -->
        <!-- Instead, you should signal the condition to denote an unusual outcome. -->
        <!-- なにこれ？訳す坪どこ？外人？歌？ -->
        You should not return a condition object as one of a set of multiple values. 
        Instead, you should signal the condition to denote an unusual outcome.
        <!-- 多値のセットをコンディションと見做して返すべきではありません。 -->
        <!-- 代わりに、普通でない結果となったこととしてコンディションを発するべきです。 -->
      </p>
      <p>
        <!-- You should signal a condition to denote an unusual outcome, -->
        <!-- rather than relying on a special return type. -->
        普通でない結果であることを示したい場合は、特殊な型を返すよりもコンディションを発するべきです。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="リストかペアか"><!-- Lists vs. Pairs -->
    <SUMMARY>
      <!-- Use the appropriate functions when manipulating lists. -->
      リスト操作には適切な関数を用いましょう。
    </SUMMARY>
    <BODY>
      <p>
        <!-- Use <code>FIRST</code> to access the first element of a list, -->
        <!-- <code>SECOND</code> to access the second element, etc. -->
        <!-- Use <code>REST</code> to access the tail of a list. -->
        <!-- Use <code>ENDP</code> to test for the end of the list. -->
        リストの第一要素へのアクセスには<code>FIRST</code>を使いましょう。
        また、<code>SECOND</code>は第二要素へのアクセスに使いましょう(以降同様)。
        リストのテール部へのアクセスには<code>REST</code>を使いましょう。
        リスト終端のテストには<code>ENDP</code>を使いましょう。
      </p>
      <p>
        <!-- Use <code>CAR</code> and <code>CDR</code> -->
        <!-- when the cons cell is not being used to implement a proper list -->
        <!-- and is instead being treated as a pair of more general objects. -->
        <!-- Use <code>NULL</code> to test for <code>NIL</code> in this context. -->
        <code>CAR</code>と<code>CDR</code>は、
        コンスセルが真正リストとして使われない場合や、[コンスセルに限らず]オブジェクト一般のペアの表現とみなされるものに使いましょう。
        また、この[用法の]文脈では、<code>NULL</code>を<code>NIL</code>かどうかのテストに使います。
      </p>
      <p>
        <!-- The latter case should be rare outside of alists, -->
        <!-- since you should be using structures and classes where they apply, -->
        <!-- and data structure libraries when you want trees. -->
        <!-- @nfunato https://twitter.com/nfunato/status/264814210570129408 -->
        後者の場合はalistを別とすれば稀でしょう。構造体やクラスが適切なときはそちらを、木構造を使いたいときはデータ構造のライブラリを使うべきだからです。
      </p>
      <p>
        <!-- Exceptionally, you may use <code>CDADR</code> and other variants -->
        <!-- on lists when manually destructuring them, -->
        <!-- instead of using a combination of several list accessor functions. -->
        <!-- In this context, using <code>CAR</code> and <code>CDR</code> -->
        <!-- instead of <code>FIRST</code> and <code>REST</code> also makes sense. -->
        <!-- However, keep in mind that it might be more appropriate in such cases -->
        <!-- to use higher-level constructs such as -->
        <!-- <code>DESTRUCTURING-BIND</code> or <code>FARE-MATCHER:MATCH</code>. -->
        手動でリストを腑分けするような場合、リストのアクセス関数を組み合わせる代わりに、
        例外的に<code>CDADR</code>やそれに類するものを使っても良いでしょう。
        この文脈では<code>FIRST</code>や<code>REST</code>でなく、代りに<code>CAR</code>や<code>CDR</code>を利用するのも理にかなったことでしょう。
        しかし、これらの場合、より高い[視点で]構造を扱うものとして、
        <code>DESTRUCTURING-BIND</code>や<code>FARE-MATCHER:MATCH</code>
        を使った方が適切な場合もあるということを常に念頭に置いておきましょう。
      </p>
    </BODY>
  </STYLEPOINT>
  <!--
  <STYLEPOINT title="Lists vs. Arrays">
    -->
  <STYLEPOINT title="リストか配列か">
    <SUMMARY>
      <!-- 
      You should use arrays rather than lists where random access matters.
      -->
      (要素に)ランダムアクセスをする場合には、リストではなく配列を用いるべきです。
    </SUMMARY>
    <BODY>
      <p>
        <!--
        <code>ELT</code> has <i>O(n)</i> behavior when used on lists.
        If you are to use random element access on an object,
        use arrays and <code>AREF</code> instead.
        -->
        <code>ELT</code> がリストで用いられた場合 <i>O(n)</i> の効率になります。
        要素にランダムアクセスする場合、配列と<code>AREF</code>の組み合せを用いましょう。
      </p>
      <p>
        <!--
        The exception is for code outside the critical path
        where the list is known to be small anyway.
        -->
        クリティカルパスの外側で、かつ、そのサイズが小さいことが予期されている場合等の例外的利用はあります。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="リストか集合か">
  <!-- <STYLEPOINT title="Lists vs. Sets"> -->
    <SUMMARY>
      <!-- You should only use lists as sets for very small lists. -->
      集合としてのリストの用法は、それが非常に小さいサイズのものに限るべきです。
    </SUMMARY>
    <BODY>
      <p>
        <!-- Using lists as representations of sets is a bad idea -->
        <!-- unless you know the lists will be small, -->
        <!-- for accessors are <i>O(n)</i> instead of <i>O(log n)</i>. -->
        <!-- For arbitrary big sets, use balanced binary trees, -->
        <!-- for instance using <code>lisp-interface-library</code>. -->
        リストが小規模であることが事前に把握できる場合を除いて、リストを集合の表現として利用するのはまずい考えです。
        [リスト表現の場合]アクセサは<i>O(log n)</i>で済むところが<i>O(n)</i>のコストをかけることになります。
        任意で大きい集合には、<code>lisp-interface-library</code>での例のように平衡2分木を使います。
      </p>
      <p>
        <!-- If you still use lists as sets, -->
        <!-- you should not <code>UNION</code> lists just to search them. -->
        それでもなお集合としてのリストを使いたいという場合、
        単に要素を探索するようなことに<code>UNION</code>[で合成した]リストを使うべきではありません。
      </p>
      <BAD_CODE_SNIPPET>
        (member foo (union list-1 list-2)) ; Bad
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (or (member foo list-1) (member foo list-2)) ; Better
      </CODE_SNIPPET>
      <p>
        <!-- Indeed, <code>UNION</code> not only conses unnecessarily, -->
        <!-- but it can be <i>O(n^2)</i> on some implementations, -->
        <!-- and is rather slow even when it's <i>O(n)</i>. -->
        勿論、<code>UNION</code>は不要なコンスを発生させるだけでなく、
        幾つかの処理系では、<i>O(n^2)</i>[の処理コスト]となることもあり、
        [良くて]<i>O(n)</i>[のコスト]だったとしても依然として遅いものです。
      </p>
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<!-- <CATEGORY title="Proper Forms"> -->
<CATEGORY title="形式の書式">
  <p>
    <!-- You must follow the proper usage regarding -->
    <!-- well-known functions, macros and special forms. -->
    関数、マクロ、スペシャルフォームの使用方法として正しいと周知されていることには*絶対に*従うべきです。
  </p>
  <!-- <STYLEPOINT title="Defining Constants"> -->
  <STYLEPOINT title="定数の定義">
    <SUMMARY>
      <!-- You must use proper defining forms for constant values. -->
      定数の定義式は、*絶対に*正しく用いるべきです。
    </SUMMARY>
    <BODY>
      <p>
        The Lisp system we primarily use, SBCL, is very picky and
        signals a condition whenever a constant is redefined to a value not
        <code>EQL</code> to its previous setting.
        You must not use <code>DEFCONSTANT</code>
        when defining variables that are not
        numbers, characters, or symbols (including booleans and keywords).
        Instead, consistently use whichever alternative
        is recommended for your project.
      </p>
      <BAD_CODE_SNIPPET>
        ;; Bad
        (defconstant +google-url+ "http://www.google.com/")
        (defconstant +valid-colors+ '(red green blue))
      </BAD_CODE_SNIPPET>
      
      
      
      
      <p>
        Open-Source libraries may use
        <code>ALEXANDRIA:DEFINE-CONSTANT</code>
        for constants other than numbers, characters and symbols
        (including booleans and keywords).
        You may use the <code>:TEST</code> keyword argument
        to specify an equality predicate.
      </p>
      <CODE_SNIPPET>
        ;; Better, for Open-Source code:
        (define-constant +google-url+ "http://www.google.com/" :test #'string=)
        (define-constant +valid-colors+ '(red green blue))
      </CODE_SNIPPET>
      <p>
        Note that with optimizing implementations, such as SBCL or CMUCL,
        defining constants this way precludes any later redefinition
        short of <code>UNINTERN</code>ing the symbol
        and recompiling all its clients.
        This may make it "interesting" to debug things at the REPL
        or to deploy live code upgrades.
        If there is a chance that your "constants" are not going to be constant
        over the lifetime of your server processes
        after taking into consideration scheduled and unscheduled code patches,
        you should consider using
        <code>DEFPARAMETER</code> or <code>DEFVAR</code> instead,
        or possibly a variant of <code>DEFINE-CONSTANT</code>
        that builds upon some future library implementing global lexicals
        rather than <code>DEFCONSTANT</code>.
        You may keep the <code>+plus+</code> convention in these cases
        to document the intent of the parameter as a constant.
      </p>
      <p>
        Also note that <code>LOAD-TIME-VALUE</code> may help you
        avoid the need for defined constants.
      </p>
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="Defining Functions"> -->
  <STYLEPOINT title="関数の定義">
    <SUMMARY>
      <!-- You should make proper use of  -->
      <!-- <code>&amp;OPTIONAL</code> and -->
      <!-- <code>&amp;KEY</code> arguments. -->
      <!-- You should not use <code>&amp;AUX</code> arguments.  -->
      <code>&amp;OPTIONAL</code>や<code>&amp;KEY</code>は適切に利用すべきです。
      <code>&amp;AUX</code>引数は利用すべきではありません。
    </SUMMARY>
    <BODY>
      <p>
        You should avoid using <code>&amp;ALLOW-OTHER-KEYS</code>,
        since it blurs the contract of a function.
        Almost any real function (generic or not) allows a certain
        fixed set of keywords, as far as its caller is concerned,
        and those are part of its contract.
        If you are implementing a method of a generic function,
        and it does not need to know
        the values of some of the keyword arguments,
        you should explicitly <code>(DECLARE (IGNORE ...))</code>
        all the arguments that you are not using.
        You must not use <code>&amp;ALLOW-OTHER-KEYS</code>
        unless you explicitly want to disable checking of allowed keys
        for all methods when invoking the generic function on arguments
        that match this particular method.
        Note that the contract of a generic function belongs in
        the <code>DEFGENERIC</code>, not in the <code>DEFMETHOD</code>
        which is basically an "implementation detail" of the generic function
        as far as the caller of the generic is concerned.
      </p>
      <p>
        A case where <code>&amp;ALLOW-OTHER-KEYS</code> is appropriate
        is when you write a wrapper function to other some other functions
        that may vary (within the computation or during development),
        and pass around a plist as a <code>&amp;REST</code> argument.
      </p>
      <p>
        You should avoid using <code>&amp;AUX</code> arguments,
        except in very short helper functions
        where they allow you to eschew a <code>LET</code>.
      </p>
      <p>
        You should avoid having both <code>&amp;OPTIONAL</code>
        and <code>&amp;KEY</code> arguments,
        unless it never makes sense to specify keyword arguments
        when the optional arguments are not all specified.
        You must not have non-<code>NIL</code> defaults
        to your <code>&amp;OPTIONAL</code> arguments
        when your function has both <code>&amp;OPTIONAL</code>
        and <code>&amp;KEY</code> arguments.
      </p>
      <p>
        For maximum portability of a library, it is good form
        that <code>DEFMETHOD</code> definitions should
        <code>(DECLARE (IGNORABLE ...))</code>
        all the required arguments that they are not using.
        Indeed, some implementations will issue a warning
        if you <code>(DECLARE (IGNORE ...))</code> those arguments,
        whereas other implementations will issue a warning
        if you fail to <code>(DECLARE (IGNORE ...))</code> them.
        <code>(DECLARE (IGNORABLE ...))</code> works on all implementations.
      </p>
      <p>
        You should avoid excessive nesting of binding forms inside a function.
        If your function ends up with massive nesting,
        you should probably break it up into several functions or macros.
        If it is really a single conceptual unit,
        consider using a macro such as <code>FARE-UTILS:NEST</code>
        to at least reduce the amount of indentation required.
        It is bad form to use <code>NEST</code> in typical short functions
        with 4 or fewer levels of nesting,
        but also bad form not to use it in the exceptional long functions
        with 10 or more levels of nesting.
        Use your judgment and consult your reviewers.
      </p>
      
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="Conditional Expressions"> -->
  <STYLEPOINT title="条件式">
    <SUMMARY>
      <!-- Use the appropriate conditional form. -->
      条件式は適切に利用しましょう。
    </SUMMARY>
    <BODY>
      <p>
        Use <code>WHEN</code> and <code>UNLESS</code>
        when there is only one alternative.
        Use <code>IF</code> when there are two alternatives
        and <code>COND</code> when there are several.
      </p>
      <p>
        However, don't use <code>PROGN</code> for an <code>IF</code> clause
        — use <code>COND</code>, <code>WHEN</code>, or <code>UNLESS</code>.
      </p>
      <p>
        Note that in Common Lisp,
        <code>WHEN</code> and <code>UNLESS</code> return <code>NIL</code>
        when the condition is not met.
        You may take advantage of it.
        Nevertheless, you may use an <code>IF</code>
        to explicitly return <code>NIL</code>
        if you have a specific reason to insist on the return value.
        You may similarly include a fall-through clause <code>(t nil)</code>
        as the last in your <cond>COND</cond>,
        or <code>(otherwise nil)</code> as the last in your <cond>CASE</cond>,
        to insist on the fact that the value returned by the conditional matters
        and that such a case is going to be used.
        You should omit the fall-through clause
        when the conditional is used for side-effects.
      </p>
      <p>
        You should prefer <code>AND</code> and <code>OR</code>
        when it leads to more concise code than using
        <code>IF</code>, <code>COND</code>,
        <code>WHEN</code> or <code>UNLESS</code>,
        and there are no side-effects involved.
        You may also use an <code>ERROR</code>
        as a side-effect in the final clause of an <code>OR</code>.
      </p>
      <p>
        You should only use <code>CASE</code> and <code>ECASE</code>
        to compare numbers, characters or symbols
        (including booleans and keywords).
        Indeed, <code>CASE</code> uses <code>EQL</code> for comparisons,
        so strings, pathnames and structures may not compare the way you expect,
        and <code>1</code> will differ from <code>1.0</code>.
      </p>
      <p>
        You should use <code>ECASE</code> and <code>ETYPECASE</code>
        in preference to <code>CASE</code> and <code>TYPECASE</code>.
        It is better to catch erroneous values early.
      </p>
      <p>
        You should not use <code>CCASE</code> or <code>CTYPECASE</code> at all.
        At least, you should not use them in server processes,
        unless you have quite robust error handling infrastructure
        and make sure not to leak sensitive data this way.
        These are meant for interactive use,
        and can cause interesting damage
        if they cause data or control to leak to attackers.
      </p>
      <p>
        You must not use gratuitous single quotes in <code>CASE</code> forms.
        This is a common error:
      </p>
      <BAD_CODE_SNIPPET>
        (case x ; Bad: silently returns NIL on mismatch
          ('bar :bar) ; Bad: catches QUOTE
          ('baz :baz)) ; Bad: also would catch QUOTE
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (ecase x ; Better: will error on mismatch
          ((bar) :bar) ; Better: won't match QUOTE
          ((baz) :baz)) ; Better: same reason
      </CODE_SNIPPET>
      <p>
        <code>'BAR</code> there is <code>(QUOTE BAR)</code>,
        meaning this leg of the case will be executed
        if <code>X</code> is <code>QUOTE</code>...
        and ditto for the second leg
        (though <code>QUOTE</code> will be caught by the first clause).
        This is unlikely to be what you really want.
      </p>
      <p>
        In <code>CASE</code> forms,
        you must use <code>otherwise</code> instead of <code>t</code>
        when you mean "execute this clause if the others fail".
        You must use <code>((t) ...)</code>
        when you mean "match the symbol T" rather than "match anything".
        You must also use <code>((nil) ...)</code>
        when you mean "match the symbol NIL" rather than "match nothing".
      </p>
      <p>
        Therefore, if you want to map booleans <code>NIL</code> and <code>T</code>
        to respective symbols <code>:BAR</code> and <code>:QUUX</code>,
        you should avoid the former way and do it the latter way:
      </p>
      <BAD_CODE_SNIPPET>
        (ecase x ; Bad: has no actual error case!
          (nil :bar)) ; Bad: matches nothing
          (t :quux)) ; Bad: matches anything
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (ecase x ; Better: will actually catch non-booleans
          ((nil) :bar)) ; Better: matches NIL
          ((t) :quux)) ; Better: matches T
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="Identity, Equality and Comparisons"> -->
  <STYLEPOINT title="同一性、等価性、比較">
    <SUMMARY>
      <!-- You should the appropriate predicates when comparing objects. -->
      オブジェクトを比較する場合は適切な述語を使用すべきです。
    </SUMMARY>
    <BODY>
      <p>
        Lisp provides four general equality predicates:
        <code>EQ</code>, <code>EQL</code>, <code>EQUAL</code>,
        and <code>EQUALP</code>,
        which subtly vary in semantics.
        Additionally, Lisp provides the type-specific predicates
        <code>=</code>, <code>CHAR=</code>, <code>CHAR-EQUAL</code>,
        <code>STRING=</code>, and <code>STRING-EQUAL</code>.
        Know the distinction!
      </p>
      <p>
        You should use <code>EQL</code> to compare objects and symbols
        for <em>identity</em>.
      </p>
      <p>
        You must not use <code>EQ</code> to compare numbers or characters.
        Two numbers or characters that are <code>EQL</code>
        are not required by Common Lisp to be <code>EQ</code>.
      </p>
      <p>
        When choosing between <code>EQ</code> and <code>EQL</code>,
        you should use <code>EQL</code> unless you are writing
        performance-critical low-level code.
        <code>EQL</code> reduces the opportunity
        for a class of embarrassing errors
        (i.e. if numbers or characters are ever compared).
        There may a tiny performance cost relative to <code>EQ</code>,
        although under SBCL, it often compiles away entirely.
        <code>EQ</code> is equivalent to <code>EQL</code> and type declarations,
        and use of it for optimization should be treated just like
        any such <a href="#Unsafe_Operations">unsafe operations</a>.
      </p>
      <p>
        You should use <code>CHAR=</code>
        for case-dependent character comparisons,
        and <code>CHAR-EQUAL</code> for case-ignoring character comparisons.
      </p>
      <p>
        You should use <code>STRING=</code>
        for case-dependent string comparisons,
        and <code>STRING-EQUAL</code> for case-ignoring string comparisons.
      </p>
      <p>
        A common mistake when using <code>SEARCH</code> on strings
        is to provide <code>STRING=</code> or <code>STRING-EQUAL</code>
        as the <code>:TEST</code> function.
        The <code>:TEST</code> function
        is given two sequence elements to compare.
        If the sequences are strings,
        the <code>:TEST</code> function is called on two characters,
        so the correct tests are <code>CHAR=</code> or <code>CHAR-EQUAL</code>.
        If you use <code>STRING=</code> or <code>STRING-EQUAL</code>,
        the result is what you expect,
        but in some Lisp implementations it's much slower.
        CCL (at least as of 8/2008)
        creates a one-character string upon each comparison, for example,
        which is very expensive.
      </p>
      <p>
        Also, you should use <code>:START</code> and <code>:END</code> arguments
        to <code>STRING=</code> or <code>STRING-EQUAL</code>
        instead of using <code>SUBSEQ</code>;
        e.g. <code>(string-equal (subseq s1 2 6) s2)</code> should instead be
        <code>(string-equal s1 s2 :start1 2 :end1 6)</code>
        This is preferable because it does not cons.
      </p>
      <p>
        You should use <code>ZEROP</code>,
        <code>PLUSP</code>, or <code>MINUSP</code>,
        instead of comparing a value to <code>0</code> or <code>0.0</code>.
      </p>
      <p>
        You must not use exact comparison on floating point numbers,
        since the vague nature of floating point arithmetic
        can produce little "errors" in numeric value.
        You should compare absolute values to a threshhold.
      </p>
      <p>
        You must use <code>=</code> to compare numbers,
        unless you really mean for <code>0</code>,
        <code>0.0</code> and <code>-0.0</code> to compare unequal,
        in which case you should use <code>EQL</code>.
        Then again, you must not usually use exact comparison
        on floating point numbers.
      </p>
      <p>
        Monetary amounts should be using decimal (rational) numbers
        to avoid the complexities and rounding errors
        of floating-point arithmetic.
        Libraries such as
        <a href="http://wukix.com/lisp-decimals">wu-decimal</a>
        may help you;
        once again, if this library is not satisfactory, see above about
        <a href="#Using_Libraries">Using Libraries</a> and
        <a href="#Open-Sourcing_Code">Open-Sourcing Code</a>.
      </p>
      
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="Iteration"> -->
  <STYLEPOINT title="繰り返し">
    <SUMMARY>
      <!-- Use the appropriate form for iteration. -->
      繰り返しの式は適切に利用しましょう。
    </SUMMARY>
    <BODY>
      <p>
        <!-- You should simpler forms such as -->
        <!-- <code>DOLIST</code> or <code>DOTIMES</code> -->
        <!-- instead of <code>LOOP</code> -->
        <!-- in simple cases when you're not going to use any -->
        <!-- of the <code>LOOP</code> facilities such as -->
        <!-- bindings, collection or block return. -->
        <code>LOOP</code>の機能である、変数の束縛・値の集約・ブロックからの脱出、等を使ったりしない、より単純な場合には、<code>DOLIST</code>や<code>DOTIMES</code>のような、より単純な構文を使うべきです。
      </p>
      <p>
        <!-- Use the <code>WITH</code> clause of <code>LOOP</code> -->
        <!-- when it will avoid a level of nesting with <code>LET</code>. -->
        <!-- You may use <code>LET</code> if it makes it clearer -->
        <!-- to return one of bound variables after the <code>LOOP</code>, -->
        <!-- rather than use a clumsy <code>FINALLY (RETURN ...)</code> form. -->
        <code>LOOP</code>の<code>WITH</code>節は、<code>LET</code>でネストレベルが深くなるのを避ける場合に使いましょう。
        束縛された変数が<code>LOOP</code>フォームの後で返されることが明確な場合は、体裁の悪い<code>FINALLY (RETURN ...)</code>を使うよりも、<code>LET</code>を使うというのも手でしょう。(訳注:<code>LOOP</code>を<code>LET</code>で囲む)
      </p>
      <p>
        <!-- In the body of a <code>DOTIMES</code>, -->
        <!-- do not set the iteration variable. -->
        <!-- (CCL will issue a compiler warning if you do.) -->
        <code>DOTIMES</code>のボディ部の内側では、繰り返し変数に値を代入してはいけません。(訳注: 要求レベルは？)
        (CCLではコンパイラはこれに警告を出します)。
        </p>
      <p>
        <!-- Most systems use unadorned symbols in the current package -->
        <!-- as <code>LOOP</code> keywords. -->
        <!-- Other systems use actual <code>:keywords</code> -->
        <!-- from the <code>KEYWORD</code> package -->
        <!-- as <code>LOOP</code> keywords. -->
        <!-- You must be consistent with the convention used in your system. -->
        <!-- g000001: system は 他のところでいうパッケージ/コードを指す? -->
        大抵のコードでは、<code>LOOP</code>のキーワードには、カレントパッケージの「飾りのない」シンボルを使いますが、
        あるコードでは、<code>LOOP</code>のキーワードとして、実際に<code>KEYWORD</code>パッケージの<code>:keywords</code>を使うこともあります。
        既存のコードの慣習に従い、一貫性を持たせなくてはなりません。
      </p>
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="I/O"> -->
  <STYLEPOINT title="入出力">
    <SUMMARY>
      <!-- Use the appropriate I/O functions. -->
      入出力関数は適切に利用しましょう。
    </SUMMARY>
    <BODY>
      <p>
        When writing a server,
        code must not send output to the standard streams such as
        <code>*STANDARD-OUTPUT*</code> or <code>*ERROR-OUTPUT*</code>.
        Instead, code must use the proper logging framework
        to output messages for debugging.
        We are running as a server, so there is no console!
      </p>
      <p>
        Code must not use <code>PRINT-OBJECT</code>
        to communicate with a user —
        <code>PRINT-OBJECT</code> is for debugging purposes only.
        Modifying any <code>PRINT-OBJECT</code> method
        must not break any public interfaces.
      </p>
      <p>
        You should not use a sequence of <code>WRITE-XXX</code>
        where a single <code>FORMAT</code> string could be used.
        Using format allows you
        to parameterize the format control string in the future
        if the need arises.
      </p>
      <p>
        You should use <code>WRITE-CHAR</code> to emit a character
        rather than <code>WRITE-STRING</code>
        to emit a single-character string.
      </p>
      <p>
        You should not use <code>(format nil "~A" value)</code>;
        you should use <code>PRINC-TO-STRING</code> instead.
      </p>
      <p>
        You should use <code>~&lt;Newline&gt;</code>
        or <code>~@&lt;Newline&gt;</code> in format strings
        to keep them from wrapping in 100-column editor windows,
        or to indent sections or clauses to make them more readable.
      </p>
      <p>
        You should not use <code>STRING-UPCASE</code>
        or <code>STRING-DOWNCASE</code>
        on format control parameters;
        instead, it should use <code>"~:@(~A~)"</code> or <code>"~(~A~)"</code>.
      </p>
      <p>
        Be careful when using the <code>FORMAT</code> conditional directive.
        The parameters are easy to forget.
      </p>
      <dl>
        <dt>No parameters, e.g. <code>"~[Siamese~;Manx~;Persian~] Cat"</code></dt>
        <dd>
          Take one format argument, which should be an integer.
          Use it to choose a clause. Clause numbers are zero-based.
          If the number is out of range, just print nothing.
          You can provide a default value
          by putting a <code>":"</code> in front of the last <code>";"</code>.
          E.g. in <code>"~[Siamese~;Manx~;Persian~:;Alley~] Cat"</code>,
          an out-of-range arg prints <code>"Alley"</code>.
        </dd>
        <dt><code>:</code> parameter, e.g. <code>"~:[Siamese~;Manx~]"</code></dt>
        <dd>
          Take one format argument.  If it's <code>NIL</code>,
          use the first clause, otherwise use the second clause.
        </dd>
        <dt><code>@</code> parameter, e.g. <code>"~@[Siamese ~a~]"</code></dt>
        <dd>
          If the next format argument is true,
          use the choice, but do NOT take the argument.
          If it's false, take one format argument and print nothing.
          (Normally the clause uses the format argument.)
        </dd>
        <dt><code>#</code> parameter, e.g. <code>"~#[ none~; ~s~; ~s and ~s~]"</code></dt>
        <dd>
          Use the number of arguments to format
          as the number to choose a clause.
          The same as no parameters in all other ways.
          Here's the full hairy example:
          <code>"Items:~#[ none~; ~S~; ~S and ~S~:;~@{~#[~; and~] ~S~^ ,~}~]."</code>
        </dd>
      </dl>
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<!-- <CATEGORY title="Optimization"> -->
<CATEGORY title="最適化">
  <!-- <STYLEPOINT title="Avoid Allocation"> -->
  <STYLEPOINT title="メモリの確保を避ける">
    <SUMMARY>
      <!-- You should avoid unnecessary allocation of memory. -->
      メモリの無用な確保は避けるべきです。
    </SUMMARY>
    <BODY>
      <p>
        <!-- In a language with automatic storage management (such as Lisp or Java), -->
        <!-- the colloquial phrase "memory leak" refers to situation -->
        <!-- where storage that is not actually needed -->
        <!-- nevertheless does not get deallocated, -->
        <!-- because it is still reachable. -->
        自動でメモリ管理が行われる言語(LispやJavaなど)において言われるメモリリークとは、
	実際にはそのメモリが必要とされていないにもかかわらず、そこに[参照が]到達可能であるがために、
	メモリが解放されないことを指しています。
      </p>
      <p>
        <!-- You should be careful that when you create objects, -->
        <!-- you don't leave them reachable after they are no longer needed! -->
        あなたは作り出したオブジェクトが不要になった後にそのオブジェクトに[参照が]届くことのないように、
        注意してオブジェクトをつくるべきです。
      </p>
      <p>
        <!-- Here's a particular trap-for-the-unwary in Common Lisp. -->
        <!-- If you make an array with a fill pointer, and put objects in it, -->
        <!-- and then set the fill pointer back to zero, -->
        <!-- those objects are still reachable as far as Lisp goes -->
        <!-- (the Common Lisp spec says that it's still OK -->
        <!-- to refer to the array entries past the end of the fill pointer). -->
        ここには特定のCommon Lispにおける、誤解しがちな罠があります。
        あなたがフィルポインタ付きの配列をつくり、そこにオブジェクトを格納した後に、
        フィルポインタを0に巻き戻した場合でも、
        それらのオブジェクトは依然としてLispからは到達可能です。
        (Common Lispの規格は、配列の要素がフィルポインタの終端以降となっても依然として参照可能とすることを認めています。)
      </p>
      <p>
        <!-- Don't cons (i.e., allocate) unnecessarily. -->
        不要なコンス(メモリの確保)をしてはなりません。
        <!-- Garbage collection is not magic. -->
        ガーベジコレクションは魔法ではありません。
        <!-- Excessive allocation is usually a performance problem. -->
        行き過ぎたメモリの確保は、大抵、実行性能に問題を与えます。
      </p>
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="Unsafe Operations"> -->
  <STYLEPOINT title="安全でない命令">
    <SUMMARY>
      <!-- You must only use faster unsafe operations -->
      <!-- when there is a clear performance need -->
      <!-- and you can document why it's correct. -->
      性能を必要とすることが明らかで、あなたがそれらの正当性のドキュメントを提供できる場合のみ、
      あなたは、高速で安全でない命令を使用すべきです。
    </SUMMARY>
    <BODY>
      <p>
        <!-- Common Lisp implementations often provide backdoors -->
        <!-- to compute some operations faster in an unsafe way. -->
		Common Lispの処理系は、しばしば、安全でない方法でいくつかの命令を高速に計算する
		裏口を提供しています。
        <!-- For instance, some libraries provide arithmetic operations -->
        <!-- that are designed to be used with fixnums only, -->
        <!-- and yield the correct result faster if provided proper arguments. -->
		実例として、いくつかのライブラリは算術命令をfixnumに限定して使用されるように設計されていて、
		fixnumの引数が与えられたときのみ正確な結果を高速に提供します。
        <!-- The downside is that the result of such operations -->
        <!-- is incorrect in case of overflow, and can -->
        <!-- have undefined behavior when called with anything but fixnums. -->
		これらの命令はfixnumでない何らかの値と共に呼び出されたとき、オーバフローによって、
		正確でない結果を返したり、未定義の動作をすることがある、欠点があります。
      </p>

      <p>
        <!-- More generally, unsafe operations -->
        <!-- will yield the correct result faster -->
        <!-- than would the equivalent safe operation -->
        <!-- if the arguments to satisfy some invariant such as -->
        <!-- being of the correct type and small enough; -->
	        より一般的にいうと、安全でない命令は、
		正しい型で十分に小さい[ある範囲に収まる]といった規定を満たす引数とともに呼び出されたとき、
		正しい結果を等価で安全な命令より、高速に生み出します。
        <!-- however if the arguments fail to satisfy the required invariants, -->
        <!-- then the operation may have undefined behavior, -->
        <!-- such as crashing the software, or, -->
        <!-- which is sometimes worse, silently giving wrong answers. -->
		しかしながら、引数が規定を満たさない引数が与えられると、
		命令はソフトウェアのクラッシュや、なんの警告もなしに間違った答えを返すといった、
		定義されていない動作をすることがあります。
        <!-- Depending on whether the software is piloting an aircraft -->
        <!-- or other life-critical device, -->
        <!-- or whether it is accounting for large amounts money, -->
        <!-- such undefined behavior can kill or bankrupt people. -->
		航空機の操縦など、生命に多大な影響を及ぼす装置や、
		大金の取扱い等が、未定義の振る舞いをするソフトウェアに依存することは、
		人を破産に追い込んだり、死に至らしめます。

        <!-- Yet proper speed can sometimes make the difference between -->
        <!-- software that's unusably slow and software that does its job; -->
        <!-- between software that is a net loss -->
        <!-- and software that can yield a profit. -->
                とはいうものの、適切な速度は、使えない程遅いソフトウェアと仕事をこなせるソフトウェア
                (ソフトウェアがもたらす損失とソフトウェアがもたらす利潤)
                の違いを生み出します。
      </p>
      <p>
        <!-- You must not define or use unsafe operations without both -->
        <!-- profiling results indicating the need for this optimization, -->
        <!-- and careful documentation explaining why it is safe to use them. -->
		あなたは、プロファイリングの結果によってその最適化の必要性を示し、
		またそれを安全のうちに扱うことができることを充分に説明できる文書なしに、
		安全でない命令を定義したり、使用してはなりません。
        <!-- Unsafe operations should be restricted to internal functions; -->
		安全でない命令は[パッケージ]内部の関数に限定すべきです。
        <!-- you should carefully documented how unsafe it is -->
        <!-- to use these functions with the wrong arguments. -->
		あなたは、それらの関数に対して不適切な引数を与えて使用した際に、
		安全でないことについて、注意深く文書化すべきです。
        <!-- You should only use unsafe operations -->
        <!-- inside functions internal to a package and -->
        <!-- you should document the use of the declarations, -->
        <!-- since calling the functions with arguments of the wrong type -->
        <!-- can lead to undefined behavior. -->
		あなたは、パッケージ内の内部関数においてのみ、安全でない命令を使用すべきであり、
		また、あなたは、不適切な型の引数で関数を呼び出して、未定義の振る舞いを引き出すことを
		宣言を使用して文書化すべきです。
        <!-- Use <code>check-type</code> in functions exported from a package -->
        <!-- to sanitize input arguments, -->
        <!-- so that internal functions are never passed illegal values. -->
		パッケージからエクスポートされる関数内では、<code>check-type</code>を使用し、
		入力される引数の妥当性を保証すれば、[パッケージ]内部関数は異常値を受け取ることはありません。
      </p>
      <p>
        <!-- On some compilers, -->
        <!-- new unsafe operations -->
        <!-- can usually be defined by combining -->
        <!-- type declarations with an <code>OPTIMIZE</code> declaration -->
        <!-- that has sufficiently high <code>SPEED</code> and low <code>SAFETY</code>. -->
		いくつかのコンパイラにおいては型宣言と、
		充分に高い<code>SPEED</code>と低い<code>SAFETY</code>宣言を伴う<code>OPTIMIZE</code>宣言の組み合わせによって、
		新たに安全でない命令を容易に定義できます。
        <!-- In addition to providing more speed for production code, -->
        <!-- such declarations may more helpful -->
        <!-- than <code>check-type</code> assertions -->
        <!-- for finding bugs at compile-time, -->
        <!-- on compilers that have type inference. -->
		くわえて、より速度を必要とする実用に供するコードにおいては、
		コンパイル時にコンパイラによる型推論がバグを見つけ出してくれるため、
		これらの宣言は<code>check-type</code>アサーションよりもより助けになるでしょう。
        <!-- These compilers may interpret those declarations as assertions -->
        <!-- if you switch to safer and slower optimize settings; -->
		あなたがより遅く安全な最適化設定に変えたときは、
		これらアサーションとしての宣言をコンパイラは逐次実行するかもしれません。
        <!-- this is good to locate a dynamic error in your code during development, -->
        <!-- but is not to be used for production code since -->
        <!-- it defeats the purpose of declarations as a performance trick. -->
		これは、あなたがコードを開発している最中に、動的なエラーを見つけやすくしますが、
		一方で、実用に供するコードにおいては性能を高めるための宣言の目的を無効化してしまいます。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="DYNAMIC-EXTENT">
    <SUMMARY>
      <!-- You should only use <code>DYNAMIC-EXTENT</code> -->
      <!-- where it matters for performance, -->
      <!-- and you can document why it is correct. -->
      <code>DYNAMIC-EXTENT</code> の利用はパフォーマンスが重要である場合に限るべきです。
      さらには、宣言の利用の正当性を文書化しておきます。
    </SUMMARY>
    <BODY>
      <p>
        <code>DYNAMIC-EXTENT</code> declaration are
        a particular case of
        <a href="#Unsafe_Operations">unsafe operations</a>.
      </p>
      <p>
        <!-- The purpose of the <code>DYNAMIC-EXTENT</code> declaration -->
        <!-- is to improve performance by reducing garbage collection -->
        <!-- in cases where it appears to be obvious that an object's lifetime -->
        <!-- is within the "dynamic extent" of a function. -->
        <!-- That means the object is created at some point -->
        <!-- after the function is called, and -->
        <!-- the object is always inaccessible after the function exits by any means. -->
        <code>DYNAMIC-EXTENT</code> 宣言の目的は、
        該当オブジェクトの生存期間が関数の“動的エクステント″の範囲に収まっていることが明白な場合において、
        ガベージ・コレクションの発生を抑制することにより、パフォーマンスを向上させることにあります。
        この動作が意味するところは、関数が呼ばれることにより、ある時点で該当オブジェクトが生成されるとして、
        この関数の実行が終了した後には、該当オブジェクトには、どのような意味でも常にアクセス不可能になる、ということです。
      </p>
      <p>
        <!--
        By declaring a variable or a local function <code>DYNAMIC-EXTENT</code>,
        the programmer <em>asserts</em> to Lisp
        that any object that is ever a value of that variable
        or the closure that is the definition of the function
        has a lifetime within the dynamic extent of the (innermost) function
        that declares the variable.
        もってまわりすぎ？
        -->
        変数や局所関数に<code>DYNAMIC-EXTENT</code>宣言を付けることにより、プログラマは、
        変数やクロージャーの寿命は(最内周の)関数の動的エクステント内であることを、Lisp処理系に<em>強引に指定</em>することになります。
      </p>
      <p>
        <!-- The Lisp implementation is then free to use that information -->
        <!-- to make the program faster. -->
        宣言時、Lisp処理系は、任意でこの情報をプログラムの速度向上のために活用することができます。
        <!-- Typically, Lisp implementations can take advantage of this knowledge -->
        <!-- to stack-allocate: -->
        典型的には、Lisp処理系は、この知識をスタック割付に役立てます:
      </p>
      <ul>
        <li>
          <!-- The lists created to store <code>&amp;REST</code> parameters. -->
          <code>&amp;REST</code> 引数により作られるリスト
        </li>
        <li>
          <!-- Lists and vector allocated within a function. -->
          アロケートが関数内で収まっているリストとベクタ
        </li>
        <li>
          <!-- Closures. -->
          クロージャー
        </li>
      </ul>
      <p>
        If the assertion is wrong, i.e. if the programmer's claim is not true,
        the results can be <em>catastrophic</em>:
        Lisp can terminate any time after the function returns,
        or it hang forever, or — worst of all —
        produce incorrect results without any runtime error!
      </p>
      <p>
        Even if the assertion is correct,
        future changes to the function might introduce
        a violation of the assertion.
        This increases the danger.
      </p>
      <p>
        In most cases, such objects are ephemeral.
        Modern Lisp implementations use generational garbage collectors,
        which are quite efficient under these circumstances.
      </p>
      <p>
        Therefore, <code>DYNAMIC-EXTENT</code> declarations
        should be used sparingly. You must only use them if:
      </p>
      <ol>
        <li>
          There is some good reason to think that the overall effect
          on performance is noticeable, and
        </li>
        <li>
          It is absolutely clear that the assertion is true.
        </li>
        <li>
          It is quite unlikely that the code will be changed
          in ways that cause the declaration to become false.
        </li>
      </ol>
      <p>
        Point (1) is a special case of
        the principle of avoiding premature optimization.
        An optimization like this only matters if such objects
        are allocated at a very high rate, e.g. "inside an inner loop".
      </p>
      <p>
        Note that is relatively easy to ascertain that
        a function will not escape the dynamic extent of the current call frame
        by analyzing where the function is called and
        what other functions it is passed to;
        therefore, you should somewhat wary of declaring a function
        <code>DYNAMIC-EXTENT</code>, but not a high-stress declaration.
        On the other hand, it is much harder to ascertain that
        none of the objects ever bound or assigned to that variable
        will escape the dynamic extent of the current call frame,
        nor will in any future modification of a function.
        Therefore, you should be extremely wary
        of declaring a variable <code>DYNAMIC-EXTENT</code>.
      </p>
      <p>
        It's sometimes hard to know what the rate will be.
        When writing a function or macro
        that's part of a library of reusable code,
        there's no a priori way to know how often the code will run.
        Ideally, tools would be available to discover
        the availability and suitability of using such an optimization
        based on running simulations and test cases, but
        in practice this isn't as easy as it ought to be.
        It's a tradeoff.
        If you're very, very sure that the assertion is true
        (that the object is only used within the dynamic scope),
        and it's not obvious how much time will be saved
        and it's not easy to measure,
        then it may be better to put in the declaration than to leave it out.
        (Ideally it would be easier to make such measurements
        than it actually is.)
      </p>
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="REDUCE vs APPLY"> -->
  <STYLEPOINT title="REDUCE か APPLY か">
    <SUMMARY>
      <!-- You should use <code>REDUCE</code> -->
      <!-- instead of <code>APPLY</code> where appropriate. -->
      <code>APPLY</code> を利用する方がより適切な場合を除いて <code>REDUCE</code> を利用すべきです。
    </SUMMARY>
    <BODY>
      <p>
        <!-- You should use <code>REDUCE</code> -->
        <!-- instead of <code>APPLY</code> and a consed-up list, -->
        <!-- where the semantics of the first operator argument -->
        <!-- otherwise guarantees the same semantics. -->
        <!-- Of course, you must use <code>APPLY</code> -->
        <!-- if it does what you want and <code>REDUCE</code> doesn't. -->
        第一引数の関数の意味論が同じと保証されるなら、<!-- ? -->
        リストを作って<code>APPLY</code>する代りに<code>REDUCE</code>を使うべきです。 
        勿論、<code>REDUCE</code>では駄目で、求めるものが<code>APPLY</code>であるなら使わなければなりません。
      </p>
      <p>
        <!-- For instance, <code>(apply #'+ (mapcar #'acc frobs)</code> -->
        <!-- should instead be <code>(reduce #'+ frobs :key #'acc)</code> -->
        例を挙げるなら、<code>(apply #'+ (mapcar #'acc frobs)</code>
        の代りに、<code>(reduce #'+ frobs :key #'acc)</code>
        となるでしょう。
      </p>
      <p>
        <!-- This is preferable because it does not do extra consing, -->
        <!-- and does not risk going beyond <code>CALL-ARGUMENTS-LIMIT</code> -->
        <!-- on implementations where that limit is small, -->
        <!-- which could blow away the stack on long lists -->
        <!-- (we want to avoid gratuitous non-portability in our code). -->
        これは、余計なコンスをしないのと、<code>CALL-ARGUMENTS-LIMIT</code>
        の上限が小さい処理系において、長いリストでスタックをあふれさせるリスクがない点で好ましいと言えます。
        (コードに無用な可搬性の無さを持ち込むのは避けたい)
      </p>
      <p>
        <!-- However, you must be careful not to use <code>REDUCE</code> -->
        <!-- in ways that needlessly increase -->
        <!-- the complexity class of the computation. -->
        <!-- For instance, <code>(REDUCE 'STRCAT ...)</code> is <i>O(n^2)</i> -->
        <!-- when an appropriate implementation is only <i>O(n)</i>. -->
        <!-- Moreover, <code>(REDUCE 'APPEND ...)</code> -->
        <!-- is also <i>O(n^2)</i> unless you specify <code>:FROM-END T</code>. -->
        <!-- In such cases, you must use proper abstractions -->
        <!-- that cover those cases instead of calling <code>REDUCE</code>, -->
        <!-- first defining them in a suitable library if need be. -->
        とはいうものの、不要に計算量を増大させるような<code>REDUCE</code>の用法には注意しなければなりません。
        例えば、<code>(REDUCE #'STRCAT ...)</code>を用いれば<i>O(n^2)</i>となりますが、
        [<code>REDUCE</code>ではなく]適切な実装を用いた場合には<i>O(n)</i>にしかなりません。
        加えて、<code>(REDUCE #'APPEND ...)</code>
        もまた、<code>:FROM-END T</code>を指定しない限り<i>O(n^2)</i>となります。
        このような場合、<code>REDUCE</code>を呼ぶのではなしに、必要とあらば、ふさわしいライブラリを定義し、
        適切な抽象を用いらなければなりません。
      </p>
      
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="Avoid NCONC"> -->
  <STYLEPOINT title="NCONCの利用は控えましょう">
    <SUMMARY>
      <!-- You should not use <code>NCONC</code>; -->
      <!-- you should use <code>APPEND</code> instead, -->
      <!-- or better data structures. -->
      <code>NCONC</code>は利用すべきではありません 
      ——代りに <code>APPEND</code> を利用すべきです。もしくはよりよい他のデータ構造を利用しましょう
    </SUMMARY>
    <BODY>
      <p>
        <!-- You should almost never use <code>NCONC</code>. -->
        <!-- You should use <code>APPEND</code> -->
        <!-- when you don't depend on any side-effect. -->
        <!-- You should use <code>ALEXANDRIA:APPENDF</code> -->
        <!-- when you need to update a variable. -->
        <!-- You should probably not depend on games -->
        <!-- being played with the <code>CDR</code> -->
        <!-- of the current CONS cell -->
        <!-- (which some might argue is suggested but not guaranteed by the specification); -->
        <!-- if you do, you must include a prominent -->
        <!-- comment explaining the use of <code>NCONC</code>; -->
        <!-- and you should probably reconsider your data representation strategy. -->
	ほぼ必ずといって良いほど<code>NCONC</code>は使わないようにすべきです。
	副作用を使っていないならAPPENDを使うべきです。
        変数を更新する必要があるときなら<code>ALEXANDRIA:APPENDF</code>をつかうべきです。
	
	[トラヴァース中の?]現在のCONSセルのCDRをもてあそぶ技法に頼るのは
	おそらくやめるべきです。
	(その技法が良いという人もいるかもしれませんが、
	その動作は仕様で保証されているわけではありません.)
        もしそういうことをするのならば、
	<code>NCONC</code>をその場で使っているという事が
	はっきりとわかるようなコメントを、そこに残すべきです。
	そして、おそらくテータの表現方法を考えなおしたほうが良いでしょう。
      </p>
      <p>
        <!-- By extension, you should avoid <code>MAPCAN</code> -->
        <!-- or the <code>NCONC</code> feature of <code>LOOP</code>. -->
        <!-- You should instead respectively use -->
        <!-- <code>ALEXANDRIA:MAPPEND</code> -->
        <!-- and the <code>APPEND</code> feature of <code>LOOP</code>. -->
	このことの延長として、<code>MAPCAN</code>、および
        <code>LOOP</code>の<code>NCONC</code>節の使用も避けるべきです。
	それらの代わりに、対応してそれぞれ
        <code>ALEXANDRIA:MAPPEND</code>と
	<code>LOOP</code>の<code>APPEND</code>節を使うべきです。
      </p>
      <p>
        <!-- <code>NCONC</code> is very seldom a good idea, -->
        <!-- since its time complexity class is no better than <code>APPEND</code>, -->
        <!-- its space complexity class also is no better than <code>APPEND</code> -->
        <!-- in the common case where no one else is sharing the side-effected list, -->
        <!-- and its bug complexity class is way higher than <code>APPEND</code>. -->
	<code>NCONC</code>が良い考えであることはほとんどありません。なぜなら、
	まず、計算時間複雑性が <code>APPEND</code>と変わりませんし、
        空間複雑性も<code>APPEND</code>と大抵変わりません(副作用つきのリストが共有されていない場合)。
	そのくせバグの複雑性は<code>APPEND</code>よりはるかに高くなります。
      </p>
      <p>
        <!-- If the small performance hit due -->
        <!-- to <code>APPEND</code> vs. <code>NCONC</code> -->
        <!-- is a limiting factor in your program, -->
        <!-- you have a big problem and are probably using the wrong data structure: -->
        <!-- you should be using sequences with constant-time append -->
        <!-- (see Okasaki's book, and add them to lisp-interface-library), -->
        <!-- or more simply you should be accumulating data in a tree -->
        <!-- that will get flattened once in linear time -->
        <!-- after the accumulation phase is complete (see how ASDF does it). -->
	もし<code>APPEND</code> vs. <code>NCONC</code>のわずかな性能の差が
	あなたのプログラムの性能を頭打ちにする主な要因だというのなら、
        あなたは大きな問題を抱えており、恐らく間違ったデータ構造を使っています。
	O(1)のAPPENDができる種類のsequenceを使いましょう
	(Okasaki<!-- Chris Okasaki -->の本を参照し、lisp-interface-libraryにそれを実装して追加してください)。
	あるいは、もっと簡単に、木構造にデータを溜めておけば、
	溜め終わったら線形時間でそれをflattenできるのでよいでしょう。
	(ASDFのやり方を参照しましょう)
      </p>
      <p>
        <!-- You may only use <code>NCONC</code>, <code>MAPCAN</code> -->
        <!-- or the <code>NCONC</code> feature of <code>LOOP</code> -->
        <!-- in low-level functions where performance matters, -->
        <!-- where the use of lists as a data structure has been vetted -->
        <!-- because these lists are known to be short, -->
        <!-- and when the function or expression the result of which are accumulated -->
        <!-- explicitly promises in its contract that it only returns fresh lists -->
        <!-- (in particular, it can't be a constant quote or backquote expression). -->
        <!-- Even then, the use of such primitives must be rare, -->
        <!-- and accompanied by justifying documentation. -->
	<code>NCONC</code>や<code>MAPCAN</code>、
	および<code>LOOP</code>の<code>NCONC</code>節を使っていいのは、
	次に挙げるような条件を満たす、低層の関数の中だけに限られるべきです。
	一、性能が重要であるとき。
	二、リストが十分に短くその使用が十分に精査されているとき。
	三、書かれる関数やコード片が新規のリストを返すことを
	明示的に誓約するとき。
	(具体的には、それが定数のquoteやbackqupteの式とならない場合)
	これらの条件を満たすような時であっても、
	それらの命令は滅多なことでは使ってはなりませんし、
	その使用を正当化するドキュメントを添付する必要があります。
      </p>
    </BODY>
  </STYLEPOINT>
</CATEGORY>



<CATEGORY title="Pitfalls">
    <STYLEPOINT title="#'FUN vs. 'FUN">
    <SUMMARY>
      <!--
      You should usually refer to a function as <code>#'FUN</code> rather than <code>'FUN</code>.
      -->
      関数の参照は、通常 <code>#'FUN</code> として参照すべきで、<code>'FUN</code>を使うべきではありません。
      <!-- formar,latterという言い方に対応させるため [guicho271828] -->
    </SUMMARY>
    <BODY>
      <p>
        <!-- The former, which reads as <code>(FUNCTION FUN)</code>, -->
        <!-- refers to the function object, and is lexically scoped. -->
        <!-- The latter, which reads as <code>(QUOTE FUN)</code>, -->
        <!-- refers to the symbol, which when called -->
        <!-- uses the global <code>FDEFINITION</code> of the symbol. -->
	前者は <code>(FUNCTION FUN)</code>として読まれ、
	関数オブジェクトを指し、そしてレキシカルスコープをもちます。
	後者は<code>(QUOTE FUN)</code>と読まれ、シンボルを指し、
	関数として呼ばれた時にはシンボルのグローバルな
	<code>FDEFINITION</code>が使われます。
      </p>
      <p>
        <!-- When using functions that take a functional argument -->
        <!-- (e.g., <code>MAPCAR</code>, <code>APPLY</code>, -->
        <!-- <code>:TEST</code> and <code>:KEY</code> arguments), -->
        <!-- you should use the <code>#'</code> to refer to the function, -->
        <!-- not just single quote. -->
	関数を引数に取る関数を使うときは(例:<code>MAPCAR</code>,
	<code>APPLY</code>,ないし<code>:TEST</code>や<code>:KEY</code>
	引数),関数を指定するのには<code>#'</code>を使うべきで、ただのシ
	ングルクオートを使うべきではありません。
      </p>
      <p>
        <!-- An exception is when you explicitly want dynamic linking, -->
        <!-- because you anticipate that -->
        <!-- the global function binding will be updated. -->
	例外は、グローバルな関数束縛が変更された時のために、
	ダイナミックな参照を得たい時です。
      </p>
      <p>
        <!-- Another exception is when you explicitly want to access -->
        <!-- a global function binding, -->
        <!-- and avoid a possible shadowing lexical binding. -->
	もうひとつの例外は、
	グローバルな束縛をシャドウするレキシカルな束縛を無視して
	グローバルな関数の束縛への参照を明示的に得たい時です。
        <!-- This shouldn't happen often, as it is usually a bad idea -->
        <!-- to shadow a function when you will want to use the shadowed function; -->
        <!-- just use a different name for the lexical function. -->
	これはまれにしか起こっては行けません。
	なぜなら、関数を参照する予定があるのなら、
	それをシャドウすべきではないからです。
	そういう時は単純に、レキシカルな束縛に別の名前を使うべきです。
      </p>
      <p>
        <!-- You must consistently use either <code>#'(lambda ...)</code> -->
        <!-- or <code>(lambda ...)</code> without <code>#'</code> everywhere. -->
        <!-- Unlike the case of <code>#'symbol</code> vs <code>'symbol</code>, -->
        <!-- it is only a syntactic difference with no semantic impact, -->
        <!-- except that the former works on Genera and the latter doesn't. -->
	<code>lambda</code>を使うなら、書き方は
	<code>#'(lambda ...)</code>か、<code>#'</code>なしの
	<code>(lambda ...)</code>に統一すべきです。
        この場合は<code>#'symbol</code> vs <code>'symbol</code>の場合とは異なり、
	意味論上の問題のない単なる構文上の問題です。
	唯一ある違いといえば、[Lispマシンの]Generaの上では前者しか動かないというだけです。
        <!-- You must use the former style if your code is intended as a library -->
        <!-- with maximal compatibility to all Common Lisp implementations; -->
        <!-- otherwise, it is optional which style you use. -->
        <!-- <code>#'</code> may be seen as a hint -->
        <!-- that you're introducing a function in expression context; -->
        <!-- but the <code>lambda</code> itself is usually sufficient hint, -->
        <!-- and concision is good. -->
        <!-- Choose wisely, but above all, -->
        <!-- consistently with yourself and other developers, -->
        <!-- within a same file, package, system, project, etc. -->
	全Common Lisp実装への最大限の対応を意図するときには、
	前者の記法を使わなくてはなりません。
        そうでないなら、どちらのスタイルでもかまいません。
        <code>#'</code>は、コード中で関数であることを示すヒントとなることがありえます。
	しかし、<code>lambda</code>自体もふつう十分なヒントになりますし、十分に丁寧です。
	お好きな方をどうぞ。しかし何に置いても、スタイルを統一することが重要です。
	自分の書く中で、あるいは他の開発者間で、あるいはファイル内で、
        あるいはパッケージ内、あるいはシステム内、プロジェクト内でも。
      </p>
      <p>
        <!-- Note that if you start writing a new system -->
        <!-- in a heavily functional style, -->
        <!-- you may consider using -->
        <!-- <a href="http://cliki.net/lambda-reader">lambda-reader</a>, -->
        <!-- a system that lets you use the unicode character <code>λ</code> -->
        <!-- instead of <code>LAMBDA</code>. -->
        <!-- But you must not start using such a syntactic extension -->
        <!-- in an existing system without getting permission from other developers. -->
	加えて、関数型スタイルを重用してシステムを新規に書き始める際は、
	<a href="http://cliki.net/lambda-reader">lambda-reader</a>の使用を考えてみても良いでしょう。
	これは、Unicodeの<code>λ</code>を<code>LAMBDA</code>の代わりに使えるライブラリです。
	しかし、既にあるシステムに他の開発者の賛同なくこういった構文拡張を導入してはなりません。
      </p>
    </BODY>
  </STYLEPOINT>
  <!-- <STYLEPOINT title="Pathnames"> -->
  <STYLEPOINT title="パスネーム">
    <SUMMARY>
      <!-- Common Lisp pathnames are tricky. Be aware of pitfalls. -->
      Common Lisp のパスネームはトリッキーです。落とし穴にはまらないよう注意しましょう。
    </SUMMARY>
    <BODY>
      <p>
        It is surprisingly hard to properly deal with pathnames in Common Lisp.
      </p>
      <p>
        First, be aware of the discrepancies between
        the syntax of Common Lisp pathnames,
        which depends on which implementation and operating system
        you are using,
        and the native syntax of pathnames on your operating system.
        The Lisp syntax may involves quoting of special characters
        such as <code>#\.</code> and <code>#\*</code>, etc.,
        in addition to the quoting of
        <code>#\\</code> and <code>#\"</code> within strings.
        By contrast, your operating system's other
        system programming languages
        (shell, C, scripting languages)
        may only have one layer of quoting, into strings.
      </p>
      <p>
        Second, when using <code>MERGE-PATHNAMES</code>,
        be wary of the treatment of the <code>HOST</code> component,
        which matters a lot on non-Unix platforms
        (and even on some Unix implementations).
        You probably should be using
        <code>ASDF-UTILS:MERGE-PATHNAMES*</code>
        instead of <code>MERGE-PATHNAMES</code>,
        especially if your expectations for relative pathnames
        are informed by the way they work in Unix or Windows;
        otherwise you might hit weird bugs whereby on some implementations,
        merging a relative pathnames with an absolute pathname
        results in overriding the absolute pathname's host
        and replace it with the host from the value of
        <code>*DEFAULT-PATHNAME-DEFAULTS*</code>
        at the time the relative pathname was created.
      </p>
      <p>
        Third, be aware that <code>DIRECTORY</code>
        is not portable across implementations
        in how it handles wildcards, sub-directories, symlinks, etc.
        There again, <code>ASDF-UTILS</code> provides several
        common abstractions to deal with pathnames.
      </p>
      <p>
        <code>LOGICAL-PATHNAME</code>s are not a portable abstraction,
        and should not be used in portable code.
        Many implementations have bugs in them, when they are supported at all.
        SBCL implements them very well,
        but strictly enforces the limitations on characters
        allowed by the standard.
        Other implementations allow arbitrary characters in such pathnames,
        but in doing so are not being conformant,
        and are still incompatible with each other in many ways.
        You should use other pathname abstractions,
        such as <code>ASDF:SYSTEM-RELATIVE-PATHNAME</code> or
        the underlying <code>ASDF-UTILS:COERCE-PATHNAME</code>.
      </p>
      
      <p>
        Finally, be aware that paths may change between
        the time you build the Lisp image for your application,
        and the time you run the application from its image.
        You should be careful to reset your image
        to forget irrelevant build-time paths and
        reinitialize any search path from current environment variables.
        <code>ASDF</code> for instance requires you to reset its paths
        with <code>ASDF:CLEAR-CONFIGURATION</code>.
      </p>
      
    </BODY>
  </STYLEPOINT>


  <STYLEPOINT title="SATISFIES">
    <SUMMARY>
      <!-- You must be careful when using a <code>SATISFIES</code> clause in a type specifier.
      -->
      <code>SATISFIES</code> 型識別子を使うときは気をつけましょう。
    </SUMMARY>
    <BODY>
      <p>
        <!-- Most Common Lisp implementations can't optimize -->
        <!-- based on a <code>SATISFIES</code> type, -->
        <!-- but many of them offer simple optimizations -->
        <!-- based on a type of the form -->
        <!-- <code>(AND FOO (SATISFIES BAR-P))</code> -->
        <!-- where the first term of the <code>AND</code> clause -->
        <!-- describes the structure of the object -->
        <!-- without any <code>SATISFIES</code> -->
        <!-- and the second term is the <code>SATISFIES</code>. -->
	ほとんどのlisp処理系は <code>SATISFIES</code> で定義された型を
	最適化できません。一方、 <code>(AND FOO (SATISFIES
	BAR-P))</code> という形の型ならば簡単な最適化を行います。すなわち、
	<code>AND</code> 節の最初の型が <code>SATISFIES</code> なしの型であり、
	２つ目の型が <code>SATISFIES</code> 型である時です。
      </p>
      <BAD_CODE_SNIPPET>
        (deftype prime-number () (satisfies prime-number-p)) ; Bad
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (deftype prime-number () (and integer (satisfies prime-number-p)) ; Better
      </CODE_SNIPPET>
      <!--
          However, <code>AND</code> in the <code>DEFTYPE</code> language
          isn't a left-to-right short-circuit operator
          as in the expression language;
          it is a symmetrical connector that allows for reordering subterms
          and doesn't guarantee short-circuiting.
          Therefore, in the above example,
          you cannot rely on the test for <code>INTEGER</code>ness
          to protect the function <code>PRIME-NUMBER-P</code>
          from being supplied non-integer arguments
          to test for being of instances of the type.
          Implementations may, and some <em>will</em>,
          invoke <code>SATISFIES</code>-specified function
          at compile-time to test various relevant objects.
          </p>
          <p>
          That is why any function specified in a <code>SATISFIES</code> clause
          MUST accept objects of any type as argument to the function,
          and MUST be defined within an <code>EVAL-WHEN</code>. 
      -->
      <p>
        ただし、 <code>DEFTYPE</code> 中の <code>AND</code> は、通常の
        <code>AND</code>のように、左から右へ評価する短絡演算子の
        ような動作はしません。これはただの「対称」
        の型連結子であって、子要素を並べる仕組みを提供するだけであり、
        そのすべての引数を必ず評価します。そのため、上の例では、
        <code>PRIME-NUMBER-P</code> の引数に与えられるのが必ず
        <code>INTEGER</code>になる、というような推測は間違いとなります。
         
        コンパイル時、処理系は <code>SATISFIES</code> で記さ
        れた関数を呼び出し、関連するオブジェクトの検査に使うことが許されていますし、あるもの
        は <em>なるべくそうしようと</em> します。
      </p>
      <p>
	これこそが、 <code>SATISFIES</code> で指定する関数は、どんな型
	の引数でも適用できるようで<em>なくてはならない</em>ことの、そ
	して<code>EVAL-WHEN</code> の中で定義され<em>なくてはいけない
	</em>ことの理由です。
      </p>
      <BAD_CODE_SNIPPET>
        (defun prime-number-p (n) ; Doubly bad!
          (let ((m (abs n)))
            (if (&lt;= m *prime-number-cutoff*)
                (small-prime-number-p m)
                (big-prime-number-p m))))
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (eval-when (:compile-toplevel :load-toplevel :execute) ; Better
          (defun prime-number-p (n)
            (when (integerp n) ; Better
              (let ((m (abs n)))
                (if (&lt;= m *prime-number-cutoff*)
                    (small-prime-number-p m)
                    (big-prime-number-p m))))))
      </CODE_SNIPPET>
      <!--
        In particular, the above means that the
        <a href="http://www.lispworks.com/documentation/HyperSpec/Body/t_satisf.htm">example</a>
        used in the Common Lisp Standard is erroneous:
        <code>(and integer (satisfies evenp))</code>
        is <em>not</em> a safe, conformant type specifier to use,
        because <code>EVENP</code> will throw an error
        rather than return <code>NIL</code>
        when passed a non-integer as an argument. 
      -->
      <p>
	特に、上のコードは<a
	href="http://www.lispworks.com/documentation/HyperSpec/Body/t_satisf.htm">HyperSpec
	の例</a>で Common Lisp 標準として示されたものが間違っていることを示しています。
	つまり上の例では、<code>(and integer (satisfies evenp))</code> は
	<em>危険</em>で、標準に沿った適切な型の指定方法ではないということです。
	上の<code>EVENP</code> は、非整数の引数を渡されれば、<code>NIL</code>を返すのではなしに、エラーを投げることでしょう。
      </p>
      <p>
	最後に。 <code>DEFTYPE</code> が、動的に生成される関数を伴った <code>SATISFIES</code> に展開される場合の落とし穴について触れておきましょう。
        <!-- Finally, there is a catch when your <code>DEFTYPE</code> code expands -->
        <!-- to a <code>SATISFIES</code> with a dynamically generated function: -->
      </p>
      <ul>
        <li>
	  実装が いつ <code>DEFTYPE</code> を展開するか、これを制御することはできません。
          <!-- You cannot control when implementations will or will not -->
          <!-- expand a <code>DEFTYPE</code>. -->
        </li>
        <li>
	  <!-- The expansion itself cannot contain a function definition -->
          <!-- or any code in the expression language. -->
	  展開結果それ自身には、関数定義や通常のlispコードを含むことができません。
        </li>
        <li>
          <!-- You cannot control when the expansion is used, -->
          <!-- it may happen in a different process -->
          <!-- that didn't expand the definition. -->
	  展開系がいつ使われるか、これを制御することはできません。例え
	  ば、展開を行ったのとは別のプロセスが、展開結果だけを使うこと
	  も考えられます。
        </li>
      </ul>
      <p>
        <!-- Therefore, you cannot merely create the function -->
        <!-- as a side-effect of expansion -->
        <!-- using <code>EVAL</code> at type-expansion time. -->
        <!-- The solution is to use -->
        <!-- <code>ASDF-FINALIZERS:EVAL-AT-TOPLEVEL</code> instead. -->
        <!-- See the very last point -->
        <!-- in the discussion about <a href="#EVAL">EVAL</a>. -->
	
	そういうわけで、型展開時に、<code>EVAL</code>を使った展開の副作用として
	関数を作ることはできないと考えてください。
	そういうことをしたいなら、
        <code>ASDF-FINALIZERS:EVAL-AT-TOPLEVEL</code> を使ってください。
	この点については、<a href="#EVAL">EVAL</a>の章でより深く議論しています。
      </p>
      <p>
        <!-- Common Lisp is hard to satisfy. -->
        Common Lisp は、そう簡単には満足(satisfy)させられない「型破りの」ものなのです。
	<!-- 意訳・・・ -->
      </p>
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<HR/>

<small>Credits:
   Adam Worrall, Dan Pierson, Matt Marjanovic, Matt Reklaitis,
   Paul Weiss, Scott McKay, Sundar Narasimhan,
   and several other people contributed.
   Special thanks to Steve Hain,
   and to the previous editors,
   in reverse chronological order Dan Weinreb and Jeremy Brown.
</small>

<p align="right">
Revision 1.20
</p>


<address>
Robert Brown
</address>

<address>
  <a HREF="mailto:tunes@google.com">François-René Rideau</a>
</address>



</GUIDE>
